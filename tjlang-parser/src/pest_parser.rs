//! Pest-based parser for TJLang
//! This replaces the recursive descent parser with a more robust pest-based solution

use pest::Parser;
use pest::iterators::Pair;
use pest_derive::Parser;
use tjlang_ast::*;
use tjlang_diagnostics::{DiagnosticCollection, SourceSpan};
use codespan::Files;

// Import the generated parser
#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct TJLangPestParser;

// The Rule enum is generated by the derive macro and is in the same scope

/// Main parser struct using pest
pub struct PestParser {
    pub diagnostics: DiagnosticCollection,
}

impl PestParser {
    /// Create a new pest parser
    pub fn new() -> Self {
        Self {
            diagnostics: DiagnosticCollection::new(),
        }
    }

    /// Parse TJLang source code
    pub fn parse(&mut self, source: &str) -> Result<Program, Box<dyn std::error::Error>> {
        // Parse using pest
        let pairs = TJLangPestParser::parse(Rule::program, source)
            .map_err(|e| format!("Parse error: {}", e))?;

        // Convert pest pairs to AST
        let program = self.parse_program(pairs, source)?;
        Ok(program)
    }

    /// Parse program from pest pairs
    fn parse_program(&mut self, mut pairs: pest::iterators::Pairs<Rule>, _source: &str) -> Result<Program, Box<dyn std::error::Error>> {
        let program_pair = pairs.next().ok_or("No program found")?;
        let span = program_pair.as_span();
        
        let mut statements = Vec::new();
        for pair in program_pair.into_inner() {
            match pair.as_rule() {
                Rule::statement => {
                    if let Some(statement) = self.parse_statement(pair)? {
                        statements.push(statement);
                    }
                }
                Rule::EOI => break, // End of input
                _ => {} // Skip other rules
            }
        }

        // Create a simple program with just statements
        // For now, we'll create a single block containing all statements
        let _block = Block {
            statements,
            span: self.create_span(span),
        };
        let program = Program {
            units: vec![ProgramUnit::Declaration(Declaration::Variable(VariableDecl {
                name: "main".to_string(),
                var_type: Type::Primitive(PrimitiveType::Any),
                value: Expression::Literal(Literal::None),
                span: self.create_span(span),
            }))],
            span: self.create_span(span),
        };
        
        Ok(program)
    }

    /// Parse statement from pest pair
    fn parse_statement(&mut self, pair: Pair<Rule>) -> Result<Option<Statement>, Box<dyn std::error::Error>> {
        match pair.as_rule() {
            Rule::statement => {
                // For now, just create a simple expression statement
                let expr = Expression::Literal(Literal::String("x".to_string()));
                Ok(Some(Statement::Expression(expr)))
            }
            _ => Ok(None)
        }
    }

    /// Create a SourceSpan from a pest span
    fn create_span(&self, span: pest::Span) -> SourceSpan {
        let mut files = Files::new();
        let file_id = files.add("input.tj", "");
        SourceSpan::new(file_id, codespan::Span::new(span.start() as u32, span.end() as u32))
    }
}