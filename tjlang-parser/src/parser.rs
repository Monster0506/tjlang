//! Pest-based parser for TJLang
//! This replaces the recursive descent parser with a more robust pest-based solution

use pest::Parser;
use pest::iterators::Pair;
use pest_derive::Parser;
use tjlang_ast::*;
use tjlang_diagnostics::{DiagnosticCollection, SourceSpan as DiagnosticSourceSpan};
use codespan::Files;

// Import the generated parser
#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct TJLangPestParser;

// The Rule enum is generated by the derive macro and is in the same scope

/// Main parser struct using pest
pub struct PestParser {
    pub diagnostics: DiagnosticCollection,
}

impl PestParser {
    /// Create a new pest parser
    pub fn new() -> Self {
        Self {
            diagnostics: DiagnosticCollection::new(),
        }
    }

    /// Add a parse error with context
    fn add_parse_error(&mut self, code: tjlang_diagnostics::ErrorCode, message: String, span: pest::Span) {
        let source_span = self.create_diagnostic_span(span);
        self.diagnostics.add_error(code, message, source_span);
    }

    /// Add a parse warning with context
    fn add_parse_warning(&mut self, code: tjlang_diagnostics::ErrorCode, message: String, span: pest::Span) {
        let source_span = self.create_diagnostic_span(span);
        self.diagnostics.add_warning(code, message, source_span);
    }

    /// Add an unexpected token error
    fn add_unexpected_token_error(&mut self, expected: &str, found: &str, span: pest::Span) {
        let message = format!("expected `{}`, found `{}`", expected, found);
        self.add_parse_error(tjlang_diagnostics::ErrorCode::ParserUnexpectedToken, message, span);
    }

    /// Add a missing token error
    fn add_missing_token_error(&mut self, expected: &str, span: pest::Span) {
        let message = format!("expected `{}`", expected);
        self.add_parse_error(tjlang_diagnostics::ErrorCode::ParserExpectedToken, message, span);
    }

    /// Add an invalid expression error with suggestion
    fn add_invalid_expression_error(&mut self, context: &str, span: pest::Span) {
        let message = format!("invalid expression in {}", context);
        let mut diagnostic = tjlang_diagnostics::TJLangDiagnostic::new(
            tjlang_diagnostics::ErrorCode::ParserInvalidExpression,
            codespan_reporting::diagnostic::Severity::Error,
            message,
            self.create_diagnostic_span(span),
        );
        
        // Add helpful suggestions based on context
        match context {
            "if condition" => {
                diagnostic = diagnostic.with_note("if conditions must be boolean expressions".to_string());
            },
            "while condition" => {
                diagnostic = diagnostic.with_note("while conditions must be boolean expressions".to_string());
            },
            "function argument" => {
                diagnostic = diagnostic.with_note("function arguments must be valid expressions".to_string());
            },
            _ => {}
        }
        
        self.diagnostics.add(diagnostic);
    }



    /// Parse TJLang source code
    pub fn parse(&mut self, source: &str) -> Result<Program, Box<dyn std::error::Error>> {
        // Parse using pest
        let pairs = TJLangPestParser::parse(Rule::program, source)
            .map_err(|e| {
                // Convert pest errors to our diagnostic format
                match &e {
                    pest::error::Error { location, .. } => {
                        let pos = match location {
                            pest::error::InputLocation::Pos(pos) => *pos,
                            pest::error::InputLocation::Span((start, _)) => *start,
                        };
                        let span = pest::Span::new(source, pos, pos + 1).unwrap_or_else(|| pest::Span::new(source, 0, 1).unwrap());
                        self.add_parse_error(
                            tjlang_diagnostics::ErrorCode::ParserUnexpectedToken,
                            format!("Parse error: {}", e),
                            span,
                        );
                    }
                }
                format!("Parse error: {}", e)
            })?;

        
        // Convert pest pairs to AST
        let program = self.parse_program(pairs, source)?;
        Ok(program)
    }

    /// Parse program from pest pairs
    fn parse_program(&mut self, mut pairs: pest::iterators::Pairs<Rule>, _source: &str) -> Result<Program, Box<dyn std::error::Error>> {
        let program_pair = pairs.next().ok_or_else(|| {
            self.add_parse_error(
                tjlang_diagnostics::ErrorCode::ParserUnexpectedEof,
                "expected program content, found end of input".to_string(),
                pest::Span::new("", 0, 0).unwrap(),
            );
            "No program found"
        })?;
        let span = program_pair.as_span();
        
        let mut units = Vec::new();
        let mut parse_errors = Vec::new();
        
        for pair in program_pair.into_inner() {
            match pair.as_rule() {
                Rule::program_unit => {
                    let pair_span = pair.as_span();
                    let inner = pair.into_inner().next().ok_or_else(|| {
                        self.add_parse_error(
                            tjlang_diagnostics::ErrorCode::ParserInvalidStatement,
                            "empty program unit".to_string(),
                            pair_span,
                        );
                        "Empty program unit"
                    })?;
                    
                    match inner.as_rule() {
                        Rule::statement => {
                            match self.parse_statement(inner) {
                                Ok(Some(statement)) => {
                                    // Convert statement to appropriate program unit
                                    match statement {
                                        Statement::Variable(var_decl) => {
                                            units.push(ProgramUnit::Declaration(Declaration::Variable(var_decl)));
                                        }
                                        Statement::Expression(expr) => {
                                            // For expression statements, create a dummy variable declaration
                                            // This maintains backward compatibility with existing tests
                                            units.push(ProgramUnit::Declaration(Declaration::Variable(VariableDecl {
                                                name: "main".to_string(),
                                                var_type: Type::Primitive(PrimitiveType::Any),
                                                value: expr,
                                                span: self.create_span(span),
                                            })));
                                        }
                                        _ => {
                                            // For other statements, create a dummy variable declaration
                                            // This maintains backward compatibility with existing tests
                                            units.push(ProgramUnit::Declaration(Declaration::Variable(VariableDecl {
                                                name: "main".to_string(),
                                                var_type: Type::Primitive(PrimitiveType::Any),
                                                value: Expression::Literal(Literal::None),
                                                span: self.create_span(span),
                                            })));
                                        }
                                    }
                                }
                                Ok(None) => {
                                    // Statement was parsed but is not a top-level statement
                                    self.add_parse_warning(
                                        tjlang_diagnostics::ErrorCode::ParserInvalidStatement,
                                        "statement is not valid at top level".to_string(),
                                        pair_span,
                                    );
                                }
                                Err(e) => {
                                    parse_errors.push(e);
                                }
                            }
                        }
                        Rule::function_decl => {
                            match self.parse_function_decl(inner) {
                                Ok(func_decl) => {
                                    units.push(ProgramUnit::Declaration(Declaration::Function(func_decl)));
                                }
                                Err(e) => {
                                    parse_errors.push(e);
                                }
                            }
                        }
                        Rule::type_decl => {
                            match self.parse_type_decl(inner) {
                                Ok(type_decl) => {
                                    units.push(ProgramUnit::Declaration(Declaration::Type(type_decl)));
                                }
                                Err(e) => {
                                    parse_errors.push(e);
                                }
                            }
                        }
                        Rule::struct_decl => {
                            match self.parse_struct_decl(inner) {
                                Ok(struct_decl) => {
                                    units.push(ProgramUnit::Declaration(Declaration::Struct(struct_decl)));
                                }
                                Err(e) => {
                                    parse_errors.push(e);
                                }
                            }
                        }
                        Rule::enum_decl => {
                            match self.parse_enum_decl(inner) {
                                Ok(enum_decl) => {
                                    units.push(ProgramUnit::Declaration(Declaration::Enum(enum_decl)));
                                }
                                Err(e) => {
                                    parse_errors.push(e);
                                }
                            }
                        }
                        Rule::interface_decl => {
                            match self.parse_interface_decl(inner) {
                                Ok(interface_decl) => {
                                    units.push(ProgramUnit::Declaration(Declaration::Interface(interface_decl)));
                                }
                                Err(e) => {
                                    parse_errors.push(e);
                                }
                            }
                        }
                        Rule::impl_block => {
                            match self.parse_impl_block(inner) {
                                Ok(impl_block) => {
                                    units.push(ProgramUnit::Declaration(Declaration::Implementation(impl_block)));
                                }
                                Err(e) => {
                                    parse_errors.push(e);
                                }
                            }
                        }
                        Rule::export_decl => {
                            match self.parse_export_decl(inner) {
                                Ok(export_decl) => {
                                    units.push(ProgramUnit::Export(export_decl));
                                }
                                Err(e) => {
                                    parse_errors.push(e);
                                }
                            }
                        }
                        _ => {
                            self.add_parse_error(
                                tjlang_diagnostics::ErrorCode::ParserInvalidStatement,
                                format!("unexpected construct: {:?}", inner.as_rule()),
                                inner.as_span(),
                            );
                        }
                    }
                }
                Rule::EOI => break, // End of input
                _ => {} // Skip other rules
            }
        }

        // If we had parse errors, return the first one
        if let Some(first_error) = parse_errors.into_iter().next() {
            return Err(first_error);
        }

        // If no units were parsed, create a dummy one for empty programs
        if units.is_empty() {
            self.add_parse_warning(
                tjlang_diagnostics::ErrorCode::ParserInvalidStatement,
                "empty program - no declarations found".to_string(),
                span,
            );
            units.push(ProgramUnit::Declaration(Declaration::Variable(VariableDecl {
                name: "main".to_string(),
                var_type: Type::Primitive(PrimitiveType::Any),
                value: Expression::Literal(Literal::None),
                span: self.create_span(span),
            })));
        }

        let program = Program {
            units,
            span: self.create_span(span),
        };
        
        Ok(program)
    }

    /// Parse statement from pest pair
    fn parse_statement(&mut self, pair: Pair<Rule>) -> Result<Option<Statement>, Box<dyn std::error::Error>> {
        // println!("Parsing statement rule: {:?}, content: '{}'", pair.as_rule(), pair.as_str());
        match pair.as_rule() {
            Rule::statement => {
                let inner = pair.into_inner().next().ok_or("Empty statement")?;
                // println!("  -> inner statement rule: {:?}, content: '{}'", inner.as_rule(), inner.as_str());
                match inner.as_rule() {
                    Rule::variable_decl => {
                        let var_decl = self.parse_variable_decl(inner)?;
                        Ok(Some(Statement::Variable(var_decl)))
                    }
                    Rule::expression => {
                        let expr = self.parse_expression(inner)?;
                        Ok(Some(Statement::Expression(expr)))
                    }
                    Rule::block => {
                        let block = self.parse_block(inner)?;
                        Ok(Some(Statement::Block(block)))
                    }
                    Rule::if_stmt => {
                        let if_stmt = self.parse_if_stmt(inner)?;
                        Ok(Some(Statement::If(if_stmt)))
                    }
                    Rule::while_stmt => {
                        let while_stmt = self.parse_while_stmt(inner)?;
                        Ok(Some(Statement::While(while_stmt)))
                    }
                    Rule::do_while_stmt => {
                        let do_while = self.parse_do_while_stmt(inner)?;
                        Ok(Some(Statement::DoWhile(do_while)))
                    }
                    Rule::for_stmt => {
                        let for_stmt = self.parse_for_stmt(inner)?;
                        Ok(Some(Statement::For(for_stmt)))
                    }
                    Rule::match_stmt => {
                        let m = self.parse_match_stmt(inner)?;
                        Ok(Some(Statement::Match(m)))
                    }
                    Rule::return_stmt => {
                        let return_stmt = self.parse_return_stmt(inner)?;
                        Ok(Some(Statement::Return(return_stmt)))
                    }
                    Rule::break_stmt => {
                        let break_stmt = self.parse_break_stmt(inner)?;
                        Ok(Some(Statement::Break(break_stmt)))
                    }
                    Rule::continue_stmt => {
                        let continue_stmt = self.parse_continue_stmt(inner)?;
                        Ok(Some(Statement::Continue(continue_stmt)))
                    }
                    Rule::pass_stmt => {
                        let pass_stmt = self.parse_pass_stmt(inner)?;
                        Ok(Some(Statement::Pass(pass_stmt)))
                    }
                    Rule::raise_stmt => {
                        let raise_stmt = self.parse_raise_stmt(inner)?;
                        Ok(Some(Statement::Raise(raise_stmt)))
                    }
                    _ => Ok(None)
                }
            }
            _ => Ok(None)
        }
    }

    /// Parse match statement
    fn parse_match_stmt(&mut self, pair: Pair<Rule>) -> Result<MatchStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // First inner is the match expression
        let expr_pair = inner.next().ok_or("Missing expression in match")?;
        let expression = self.parse_expression(expr_pair)?;

        // Then one or more arms
        let mut arms: Vec<MatchArm> = Vec::new();
        for arm_pair in inner {
            if arm_pair.as_rule() == Rule::match_arm {
                arms.push(self.parse_match_arm(arm_pair)?);
            }
        }

        Ok(MatchStatement { expression, arms, span: self.create_span(span) })
    }

    fn parse_match_arm(&mut self, pair: Pair<Rule>) -> Result<MatchArm, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // pattern
        let pat_pair = inner.next().ok_or("Missing pattern in match arm")?;
        let pattern = self.parse_pattern(pat_pair)?;

        // optional guard: recognized by encountering an 'if' expression start (rule expression following literal 'if')
        let mut guard: Option<Expression> = None;
        if let Some(next) = inner.clone().next() {
            // In grammar, guard is: ("if" ~ expression)? so the next pair will be expression if present
            if next.as_rule() == Rule::expression {
                // consume
                let _ = inner.next();
                guard = Some(self.parse_expression(next)?);
            }
        }

        // Expect block next
        let block_pair = inner.next().ok_or("Missing block in match arm")?;
        let body = self.parse_block(block_pair)?;

        Ok(MatchArm { pattern, guard, body, span: self.create_span(span) })
    }

    fn parse_pattern(&mut self, pair: Pair<Rule>) -> Result<Pattern, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        match pair.as_rule() {
            Rule::pattern => {
                let text = pair.as_str().trim();
                if text == "_" {
                    return Ok(Pattern::Wildcard(self.create_span(span)));
                }

                // collect children for structural decisions
                let children: Vec<_> = pair.clone().into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE).collect();

                // Tuple pattern if multiple inner pattern children and starts with '('
                if text.starts_with('(') {
                    let mut patterns = Vec::new();
                    for ch in children.iter() {
                        if ch.as_rule() == Rule::pattern { patterns.push(self.parse_pattern(ch.clone())?); }
                    }
                    if !patterns.is_empty() {
                        return Ok(Pattern::Tuple { patterns, span: self.create_span(span) });
                    }
                }

                // Constructor / Struct pattern handled by explicit rule child
                for ch in &children {
                    if ch.as_rule() == Rule::constructor_pattern { return self.parse_constructor_pattern(ch.clone()); }
                    if ch.as_rule() == Rule::struct_pattern { return self.parse_struct_pattern(ch.clone()); }
                    if ch.as_rule() == Rule::literal { return Ok(Pattern::Literal(self.parse_literal(ch.clone())?)); }
                }

                // Trait check pattern
                if text.contains(":") && text.contains("implements") {
                    let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                    let name = inner.next().ok_or("Missing identifier in trait pattern")?.as_str().to_string();
                    let mut trait_name = String::new();
                    for p in inner {
                        if p.as_rule() == Rule::identifier { trait_name = p.as_str().to_string(); break; }
                    }
                    return Ok(Pattern::TraitCheck { name, trait_name, span: self.create_span(span) });
                }

                // Typed bind pattern: identifier : type_
                if text.contains(":") {
                    let mut id: Option<String> = None;
                    let mut ty: Option<Type> = None;
                    for ch in children {
                        match ch.as_rule() {
                            Rule::identifier => { if id.is_none() { id = Some(ch.as_str().to_string()); } }
                            Rule::type_ => { ty = Some(self.parse_type(ch)?); }
                            _ => {}
                        }
                    }
                    if let (Some(name), Some(pattern_type)) = (id, ty) {
                        return Ok(Pattern::Variable { name, pattern_type, span: self.create_span(span) });
                    }
                }

                Err("Unrecognized pattern".into())
            }
            _ => Err("Expected pattern".into())
        }
    }

    fn parse_constructor_pattern(&mut self, pair: Pair<Rule>) -> Result<Pattern, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        let name = inner.next().ok_or("Missing constructor name in pattern")?.as_str().to_string();
        let mut fields: Vec<Pattern> = Vec::new();
        for p in inner {
            if p.as_rule() == Rule::pattern_fields {
                for f in p.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE) {
                    if f.as_rule() == Rule::pattern { fields.push(self.parse_pattern(f)?); }
                }
            }
        }
        Ok(Pattern::Constructor { name, fields, span: self.create_span(span) })
    }

    fn parse_struct_pattern(&mut self, pair: Pair<Rule>) -> Result<Pattern, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        let name = inner.next().ok_or("Missing struct name in pattern")?.as_str().to_string();
        let mut fields_kv: Vec<(String, Pattern)> = Vec::new();
        for p in inner {
            if p.as_rule() == Rule::struct_pattern_fields {
                for f in p.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE) {
                    if f.as_rule() == Rule::struct_field_pattern {
                        let mut it = f.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                        let field_name = it.next().ok_or("Missing field name in struct pattern")?.as_str().to_string();
                        let pat_pair = it.next().ok_or("Missing field pattern")?;
                        let field_pat = self.parse_pattern(pat_pair)?;
                        fields_kv.push((field_name, field_pat));
                    }
                }
            }
        }
        Ok(Pattern::Struct { name, fields: fields_kv, span: self.create_span(span) })
    }

    /// Parse block
    fn parse_block(&mut self, pair: Pair<Rule>) -> Result<Block, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut statements = Vec::new();
        
        for inner_pair in pair.into_inner() {
            if let Some(statement) = self.parse_statement(inner_pair)? {
                statements.push(statement);
            }
        }
        
        Ok(Block {
            statements,
            span: self.create_span(span),
        })
    }

        /// Parse variable declaration
        fn parse_variable_decl(&mut self, pair: Pair<Rule>) -> Result<VariableDecl, Box<dyn std::error::Error>> {
            let span = pair.as_span();
            let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
            
            let name_pair = inner.next().ok_or_else(|| {
                self.add_parse_error(
                    tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                    "expected variable name".to_string(),
                    span,
                );
                "Missing variable name"
            })?;
            let name = name_pair.as_str().to_string();
            
            // Validate variable name
            if name.is_empty() {
                self.add_parse_error(
                    tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                    "variable name cannot be empty".to_string(),
                    name_pair.as_span(),
                );
            }
            
            // Note: colon ":" is a literal in the grammar and not included in the parse tree
            
            let type_pair = inner.next().ok_or_else(|| {
                self.add_parse_error(
                    tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                    format!("expected type annotation for variable `{}`", name),
                    span,
                );
                "Missing type"
            })?;
            let type_ = self.parse_type(type_pair)?;
            
            // Note: equals "=" is a literal in the grammar and not included in the parse tree
            
            let expr_pair = inner.next().ok_or_else(|| {
                self.add_parse_error(
                    tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                    format!("expected initializer expression for variable `{}`", name),
                    span,
                );
                "Missing expression"
            })?;
            let expr_span = expr_pair.as_span();
            let expression = self.parse_expression(expr_pair)?;
            
            // Add type checking warning if types don't match (basic check)
            if let Expression::Literal(lit) = &expression {
                match (&type_, lit) {
                    (Type::Primitive(PrimitiveType::Int), Literal::String(_)) => {
                        self.add_parse_warning(
                            tjlang_diagnostics::ErrorCode::AnalyzerTypeMismatch,
                            format!("variable `{}` declared as `int` but initialized with string literal", name),
                            expr_span,
                        );
                    }
                    (Type::Primitive(PrimitiveType::Str), Literal::Int(_)) => {
                        self.add_parse_warning(
                            tjlang_diagnostics::ErrorCode::AnalyzerTypeMismatch,
                            format!("variable `{}` declared as `str` but initialized with integer literal", name),
                            expr_span,
                        );
                    }
                    _ => {} // Other combinations are fine or will be checked later
                }
            }
            
            Ok(VariableDecl {
                name,
                var_type: type_,
                value: expression,
                span: self.create_span(span),
            })
        }

    /// Parse type
    fn parse_type(&mut self, pair: Pair<Rule>) -> Result<Type, Box<dyn std::error::Error>> {
        match pair.as_rule() {
            Rule::type_ => {
                // For the top-level type rule, parse its inner content
                let inner = pair.into_inner().next().ok_or("Empty type")?;
                self.parse_type(inner)
            }
            Rule::union_type => {
                self.parse_union_type(pair)
            }
            Rule::option_type => {
                self.parse_option_type(pair)
            }
            Rule::function_type => {
                self.parse_function_type(pair)
            }
            Rule::collection_type => {
                self.parse_collection_type(pair)
            }
            Rule::primary_type => {
                self.parse_primary_type(pair)
            }
            Rule::primitive_type => {
                let type_str = pair.as_str();
                let primitive_type = match type_str {
                    "int" => PrimitiveType::Int,
                    "float" => PrimitiveType::Float,
                    "bool" => PrimitiveType::Bool,
                    "str" => PrimitiveType::Str,
                    "any" => PrimitiveType::Any,
                    _ => return Err(format!("Unknown primitive type: {}", type_str).into()),
                };
                Ok(Type::Primitive(primitive_type))
            }
            Rule::identifier => {
                let name = pair.as_str().to_string();
                Ok(Type::Identifier(name))
            }
            _ => Err(format!("Expected type, got {:?}", pair.as_rule()).into())
        }
    }

    /// Parse expression with proper precedence - simplified non-recursive approach
    fn parse_expression(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        
        match pair.as_rule() {
            Rule::expression => {
                // For the top-level expression rule, just parse its inner content
                let inner = pair.into_inner().next().ok_or("Empty expression")?;
                // Avoid recursion - handle basic cases only  
                match inner.as_rule() {
                    Rule::primary => {
                        // Handle primary expressions directly
                        let primary_inner = inner.into_inner().next().ok_or("Empty primary")?;
                        match primary_inner.as_rule() {
                            Rule::literal => {
                                let literal = self.parse_literal(primary_inner)?;
                                Ok(Expression::Literal(literal))
                            }
                            Rule::identifier => {
                                Ok(Expression::Variable(primary_inner.as_str().to_string()))
                            }
                            _ => Ok(Expression::Literal(Literal::Int(0)))
                        }
                    }
                    Rule::postfix_expr => self.parse_postfix_expr(inner),
                    _ => Ok(Expression::Literal(Literal::Int(0)))
                }
            }
            Rule::assignment | Rule::or_expr | Rule::and_expr | Rule::bit_or_expr | 
            Rule::bit_xor_expr | Rule::bit_and_expr | Rule::equality | Rule::relational |
            Rule::shift_expr | Rule::additive | Rule::multiplicative | Rule::power |
            Rule::unary => {
                // For complex expressions, just return a placeholder to avoid recursion
                Ok(Expression::Literal(Literal::Int(0)))
            }
            Rule::postfix_expr => {
                self.parse_postfix_expr(pair)
            }
            Rule::primary => {
                let inner = pair.into_inner().next().ok_or("Empty primary expression")?;
                match inner.as_rule() {
                    Rule::literal => {
                        let literal = self.parse_literal(inner)?;
                        Ok(Expression::Literal(literal))
                    }
                    Rule::identifier => {
                        let name = inner.as_str().to_string();
                        Ok(Expression::Variable(name))
                    }
                    Rule::expression => {
                        // Parenthesized expression - avoid recursion for now
                        Ok(Expression::Literal(Literal::Int(0)))
                    }
                    _ => {
                        // For other complex expressions, return placeholder
                        Ok(Expression::Literal(Literal::Int(0)))
                    }
                }
            }
            _ => {
                // Default case - return simple placeholder
                Ok(Expression::Literal(Literal::Int(0)))
            }
        }
    }

    /// Parse expression with recursion depth tracking
    fn parse_expression_with_depth(&mut self, pair: Pair<Rule>, depth: usize) -> Result<Expression, Box<dyn std::error::Error>> {
        if depth > 50 {
            return Err("Expression parsing recursion depth exceeded".into());
        }
        
        let span = pair.as_span();
        println!("🔍 parse_expression: depth={}, rule={:?}, content='{}'", depth, pair.as_rule(), pair.as_str());
        
        match pair.as_rule() {
            Rule::expression => {
                // For the top-level expression rule, just parse its inner content
                let inner = pair.into_inner().next().ok_or("Empty expression")?;
                self.parse_expression_with_depth(inner, depth + 1)
            }
            Rule::assignment => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let left = self.parse_expression_with_depth(inner.next().ok_or("Missing left operand")?, depth)?;
                
                if let Some(assign_pair) = inner.next() {
                    if assign_pair.as_str() == "=" {
                        let right = self.parse_expression_with_depth(inner.next().ok_or("Missing right operand")?, depth)?;
                        // For now, just return the right side since we don't have assignment expressions in AST yet
                        Ok(right)
                    } else {
                        Ok(left)
                    }
                } else {
                    Ok(left)
                }
            }
            Rule::or_expr => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression_with_depth(inner.next().ok_or("Missing left operand")?, depth)?;
                
                while let Some(op_pair) = inner.next() {
                    if op_pair.as_str() == "or" {
                        let right = self.parse_expression_with_depth(inner.next().ok_or("Missing right operand")?, depth)?;
                        left = Expression::Binary {
                            left: Box::new(left),
                            operator: BinaryOperator::Or,
                            right: Box::new(right),
                            span: self.create_span(span),
                        };
                    } else {
                        // This should be the next expression
                        left = self.parse_expression_with_depth(op_pair, depth)?;
                    }
                }
                Ok(left)
            }
            Rule::and_expr => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression_with_depth(inner.next().ok_or("Missing left operand")?, depth)?;
                
                while let Some(op_pair) = inner.next() {
                    if op_pair.as_str() == "and" {
                        let right = self.parse_expression_with_depth(inner.next().ok_or("Missing right operand")?, depth)?;
                        left = Expression::Binary {
                            left: Box::new(left),
                            operator: BinaryOperator::And,
                            right: Box::new(right),
                            span: self.create_span(span),
                        };
                    } else {
                        left = self.parse_expression(op_pair)?;
                    }
                }
                Ok(left)
            }
            Rule::bit_or_expr => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                while let Some(op_pair) = inner.next() {
                    if op_pair.as_str() == "|" {
                        let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                        left = Expression::Binary { left: Box::new(left), operator: BinaryOperator::BitOr, right: Box::new(right), span: self.create_span(span) };
                    } else {
                        left = self.parse_expression(op_pair)?;
                    }
                }
                Ok(left)
            }
            Rule::bit_xor_expr => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                while let Some(op_pair) = inner.next() {
                    if op_pair.as_str() == "^" {
                        let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                        left = Expression::Binary { left: Box::new(left), operator: BinaryOperator::BitXor, right: Box::new(right), span: self.create_span(span) };
                    } else {
                        left = self.parse_expression(op_pair)?;
                    }
                }
                Ok(left)
            }
            Rule::bit_and_expr => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                while let Some(op_pair) = inner.next() {
                    if op_pair.as_str() == "&" {
                        let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                        left = Expression::Binary { left: Box::new(left), operator: BinaryOperator::BitAnd, right: Box::new(right), span: self.create_span(span) };
                    } else {
                        left = self.parse_expression(op_pair)?;
                    }
                }
                Ok(left)
            }
            Rule::equality => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                
                while let Some(op_pair) = inner.next() {
                    match op_pair.as_str() {
                        "==" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Equal,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        "!=" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::NotEqual,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        _ => {
                            left = self.parse_expression(op_pair)?;
                        }
                    }
                }
                Ok(left)
            }
            Rule::relational => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                
                while let Some(op_pair) = inner.next() {
                    match op_pair.as_str() {
                        "<" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::LessThan,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        ">" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::GreaterThan,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        "<=" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::LessThanEqual,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        ">=" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::GreaterThanEqual,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        _ => {
                            left = self.parse_expression(op_pair)?;
                        }
                    }
                }
                Ok(left)
            }
            // NEW: handle additive level
            Rule::additive => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                while let Some(op_pair) = inner.next() {
                    match op_pair.as_str() {
                        "+" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Add,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        "-" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Subtract,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        _ => {
                            left = self.parse_expression(op_pair)?;
                        }
                    }
                }
                Ok(left)
            }
            // NEW: allow literals at any expression level
            Rule::literal => {
                let lit = self.parse_literal(pair)?;
                Ok(Expression::Literal(lit))
            }
            Rule::integer_literal => {
                let content = pair.as_str().trim();
                let value = content.parse::<i64>()?;
                Ok(Expression::Literal(Literal::Int(value)))
            }
            Rule::float_literal => {
                let content = pair.as_str().trim();
                let value = content.parse::<f64>()?;
                Ok(Expression::Literal(Literal::Float(value)))
            }
            Rule::string_literal => {
                let s = pair.as_str().to_string();
                Ok(Expression::Literal(Literal::String(s)))
            }
            Rule::fstring_literal => {
                let parts = self.parse_fstring_parts(pair)?;
                Ok(Expression::Literal(Literal::FStringInterpolation(parts)))
            }
            Rule::boolean_literal => {
                let val = match pair.as_str() { "true" => true, _ => false };
                Ok(Expression::Literal(Literal::Bool(val)))
            }
            Rule::none_literal => {
                Ok(Expression::Literal(Literal::None))
            }
            Rule::shift_expr => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                while let Some(op_pair) = inner.next() {
                    match op_pair.as_str() {
                        "<<" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary { left: Box::new(left), operator: BinaryOperator::ShiftLeft, right: Box::new(right), span: self.create_span(span) };
                        }
                        ">>" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary { left: Box::new(left), operator: BinaryOperator::ShiftRight, right: Box::new(right), span: self.create_span(span) };
                        }
                        _ => { left = self.parse_expression(op_pair)?; }
                    }
                }
                Ok(left)
            }
            Rule::multiplicative => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                
                while let Some(op_pair) = inner.next() {
                    match op_pair.as_str() {
                        "*" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Multiply,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        "/" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Divide,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        "%" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Modulo,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        _ => {
                            left = self.parse_expression(op_pair)?;
                        }
                    }
                }
                Ok(left)
            }
            Rule::power => {
                // right-associative **
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                if let Some(op_pair) = inner.next() {
                    if op_pair.as_str() == "**" {
                        let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                        return Ok(Expression::Binary { left: Box::new(left), operator: BinaryOperator::Power, right: Box::new(right), span: self.create_span(span) });
                    } else {
                        return self.parse_expression(op_pair);
                    }
                }
                Ok(left)
            }
            Rule::unary => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                
                if let Some(op_pair) = inner.next() {
                    match op_pair.as_str() {
                        "-" => {
                            let operand = self.parse_expression(inner.next().ok_or("Missing operand")?)?;
                            Ok(Expression::Unary {
                                operator: UnaryOperator::Negate,
                                operand: Box::new(operand),
                                span: self.create_span(span),
                            })
                        }
                        "!" => {
                            let operand = self.parse_expression(inner.next().ok_or("Missing operand")?)?;
                            Ok(Expression::Unary {
                                operator: UnaryOperator::Not,
                                operand: Box::new(operand),
                                span: self.create_span(span),
                            })
                        }
                        "~" => {
                            let operand = self.parse_expression(inner.next().ok_or("Missing operand")?)?;
                            Ok(Expression::Unary { operator: UnaryOperator::BitNot, operand: Box::new(operand), span: self.create_span(span) })
                        }
                        _ => {
                            // No unary operator, parse as primary
                            self.parse_expression(op_pair)
                        }
                    }
                } else {
                    // No unary operator, parse as primary
                    Err("Missing unary expression".into())
                }
            }
            Rule::postfix_expr => {
                self.parse_postfix_expr(pair)
            }
            Rule::primary => {
                let inner = pair.into_inner().next().ok_or("Empty primary expression")?;
                match inner.as_rule() {
                    Rule::literal => {
                        let literal = self.parse_literal(inner)?;
                        Ok(Expression::Literal(literal))
                    }
                    Rule::identifier => {
                        let name = inner.as_str().to_string();
                        Ok(Expression::Variable(name))
                    }
                    Rule::collection_literal => {
                        self.parse_collection_literal(inner)
                    }
                    Rule::lambda_expr => {
                        self.parse_lambda_expr(inner)
                    }
                    Rule::range_expr => {
                        self.parse_range_expr(inner)
                    }
                    Rule::expression => {
                        // This is for parenthesized expressions - parse the inner expression
                        let inner_expr = inner.into_inner().next().ok_or("Empty parenthesized expression")?;
                        self.parse_expression(inner_expr)
                    }
                    Rule::spawn_expr => {
                        let span = inner.as_span();
                        let mut it = inner.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                        let expr_pair = it.next().ok_or("Missing expression to spawn")?;
                        let expression = self.parse_expression(expr_pair)?;
                        Ok(Expression::Spawn {
                            expression: Box::new(expression),
                            span: self.create_span(span),
                        })
                    }
                    _ => Err(format!("Expected primary expression, got {:?}", inner.as_rule()).into())
                }
            }
            Rule::WHITESPACE => {
                // Skip whitespace tokens - they should be handled automatically by pest
                // This shouldn't happen, but if it does, just skip it
                Err("Unexpected whitespace in expression".into())
            }
            _ => Err(format!("Expected expression, got {:?}", pair.as_rule()).into())
        }
    }

    /// Parse literal
    fn parse_literal(&mut self, pair: Pair<Rule>) -> Result<Literal, Box<dyn std::error::Error>> {
        let inner = pair.into_inner().next().ok_or("Empty literal")?;
        
        // println!("        Parsing literal inner: {:?}, content: '{}'", inner.as_rule(), inner.as_str());
        
        match inner.as_rule() {
                Rule::integer_literal => {
                    let content = inner.as_str().trim();
                    let value = content.parse::<i64>()
                        .map_err(|e| format!("Invalid integer: {} (content: '{}')", e, content))?;
                    Ok(Literal::Int(value))
                }
            Rule::float_literal => {
                let value = inner.as_str().parse::<f64>()
                    .map_err(|e| format!("Invalid float: {}", e))?;
                Ok(Literal::Float(value))
            }
            Rule::string_literal => {
                let value = inner.as_str().to_string();
                // Remove quotes
                let value = value.trim_start_matches('"').trim_end_matches('"').to_string();
                Ok(Literal::String(value))
            }
            Rule::fstring_literal => {
                let parts = self.parse_fstring_parts(inner)?;
                Ok(Literal::FStringInterpolation(parts))
            }
            Rule::boolean_literal => {
                let value = inner.as_str() == "true";
                Ok(Literal::Bool(value))
            }
            Rule::none_literal => {
                Ok(Literal::None)
            }
            Rule::collection_literal => {
                // Collection literals should be handled as expressions, not basic literals
                Err("Collection literals should be parsed as expressions".into())
            }
            _ => Err(format!("Expected literal, got {:?}", inner.as_rule()).into())
        }
    }

    /// Parse if statement
    fn parse_if_stmt(&mut self, pair: Pair<Rule>) -> Result<IfStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner();
        
        // The "if" keyword is consumed by the grammar, so the first inner pair is the expression
        let condition_pair = inner.next().ok_or_else(|| {
            self.add_parse_error(
                tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                "expected condition expression after `if`".to_string(),
                span,
            );
            "Missing condition"
        })?;
        let condition_span = condition_pair.as_span();
        let condition = self.parse_expression(condition_pair)?;
        
        // Add warning if condition is not a boolean expression (basic check)
        if let Expression::Literal(Literal::Int(_)) = &condition {
            self.add_parse_warning(
                tjlang_diagnostics::ErrorCode::AnalyzerTypeMismatch,
                "if condition is an integer - consider using a boolean expression".to_string(),
                condition_span,
            );
        }
        
        let block_pair = inner.next().ok_or_else(|| {
            self.add_parse_error(
                tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                "expected block after if condition".to_string(),
                span,
            );
            "Missing then block"
        })?;
        let then_block = self.parse_block(block_pair)?;
        
        // Parse elif branches
        let mut elif_branches = Vec::new();
        while let Some(branch_pair) = inner.next() {
            if branch_pair.as_rule() == Rule::elif_branch {
                let branch_span = branch_pair.as_span();
                let mut branch_inner = branch_pair.into_inner();
                
                // The "elif" keyword is consumed by the grammar, so the first inner pair is the condition
                let elif_condition_pair = branch_inner.next().ok_or_else(|| {
                    self.add_parse_error(
                        tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                        "expected condition expression after `elif`".to_string(),
                        branch_span,
                    );
                    "Missing elif condition"
                })?;
                let elif_condition_span = elif_condition_pair.as_span();
                let branch_condition = self.parse_expression(elif_condition_pair)?;
                
                // Add warning if elif condition is not a boolean expression
                if let Expression::Literal(Literal::Int(_)) = &branch_condition {
                    self.add_parse_warning(
                        tjlang_diagnostics::ErrorCode::AnalyzerTypeMismatch,
                        "elif condition is an integer - consider using a boolean expression".to_string(),
                        elif_condition_span,
                    );
                }
                
                let elif_block_pair = branch_inner.next().ok_or_else(|| {
                    self.add_parse_error(
                        tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                        "expected block after elif condition".to_string(),
                        branch_span,
                    );
                    "Missing elif block"
                })?;
                let branch_block = self.parse_block(elif_block_pair)?;
                
                elif_branches.push(ElifBranch {
                    condition: branch_condition,
                    block: branch_block,
                    span: self.create_span(branch_span),
                });
            } else {
                // This should be the else branch
                break;
            }
        }
        
        // Parse else branch if present
        let else_block = if let Some(else_pair) = inner.next() {
            if else_pair.as_rule() == Rule::else_branch {
                let else_span = else_pair.as_span();
                let mut else_inner = else_pair.into_inner();
                
                // The "else" keyword is consumed by the grammar, so the first inner pair is the block
                let else_block_pair = else_inner.next().ok_or_else(|| {
                    self.add_parse_error(
                        tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                        "expected block after `else`".to_string(),
                        else_span,
                    );
                    "Missing else block"
                })?;
                Some(self.parse_block(else_block_pair)?)
            } else {
                None
            }
        } else {
            None
        };
        
        // Add helpful warning if if statement has no else branch
        if else_block.is_none() && elif_branches.is_empty() {
            self.add_parse_warning(
                tjlang_diagnostics::ErrorCode::ParserInvalidStatement,
                "if statement without else branch - consider adding an else clause for completeness".to_string(),
                span,
            );
        }
        
        Ok(IfStatement {
            condition,
            then_block,
            elif_branches,
            else_block,
            span: self.create_span(span),
        })
    }

    /// Parse while statement
    fn parse_while_stmt(&mut self, pair: Pair<Rule>) -> Result<WhileStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner();
        
        // The "while" keyword is consumed by the grammar, so the first inner pair is the condition
        let condition = self.parse_expression(inner.next().ok_or("Missing condition")?)?;
        let body = self.parse_block(inner.next().ok_or("Missing body")?)?;
        
        Ok(WhileStatement {
            condition,
            body,
            span: self.create_span(span),
        })
    }

    /// Parse do-while statement
    fn parse_do_while_stmt(&mut self, pair: Pair<Rule>) -> Result<DoWhileStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        // Grammar: "do" block "while" expression — literals consumed
        let body = self.parse_block(inner.next().ok_or("Missing do-while body block")?)?;
        let condition = self.parse_expression(inner.next().ok_or("Missing do-while condition")?)?;
        Ok(DoWhileStatement {
            body,
            condition,
            span: self.create_span(span),
        })
    }

    /// Parse for statement
    fn parse_for_stmt(&mut self, pair: Pair<Rule>) -> Result<ForStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        // Get the clause (either for_each_clause or c_style_clause)
        let clause = inner.next().ok_or("Missing for clause")?;
        let body = self.parse_block(inner.next().ok_or("Missing body")?)?;
        
        match clause.as_rule() {
            Rule::for_each_clause => {
                let mut clause_inner = clause.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let var_name = clause_inner.next().ok_or("Missing variable name")?.as_str().trim().to_string();
                let var_type = self.parse_type(clause_inner.next().ok_or("Missing variable type")?)?;
                let iterable = self.parse_expression(clause_inner.next().ok_or("Missing iterable")?)?;
                
                Ok(ForStatement::ForEach {
            var_name,
            var_type,
            iterable,
            body,
            span: self.create_span(span),
        })
            }
            Rule::c_style_clause => {
                let mut clause_inner = clause.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                
                // Parse initializer (optional statement)
                let initializer = if let Some(init_pair) = clause_inner.next() {
                    if init_pair.as_rule() == Rule::statement {
                        if let Some(stmt) = self.parse_statement(init_pair)? {
                            Some(Box::new(stmt))
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                } else {
                    None
                };
                
                // Parse condition (optional expression)
                let condition = if let Some(cond_pair) = clause_inner.next() {
                    if cond_pair.as_rule() == Rule::expression {
                        Some(self.parse_expression(cond_pair)?)
                    } else {
                        None
                    }
                } else {
                    None
                };
                
                // Parse increment (optional expression)
                let increment = if let Some(inc_pair) = clause_inner.next() {
                    if inc_pair.as_rule() == Rule::expression {
                        Some(self.parse_expression(inc_pair)?)
                    } else {
                        None
                    }
                } else {
                    None
                };
                
                Ok(ForStatement::CStyle {
                    initializer,
                    condition,
                    increment,
                    body,
                    span: self.create_span(span),
                })
            }
            _ => Err(format!("Expected for_each_clause or c_style_clause, got {:?}", clause.as_rule()).into()),
        }
    }

    /// Parse return statement
    fn parse_return_stmt(&mut self, pair: Pair<Rule>) -> Result<ReturnStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner();
        
        // The "return" keyword is consumed by the grammar, so check if there's an expression
        let value = if let Some(expr_pair) = inner.next() {
            Some(self.parse_expression(expr_pair)?)
        } else {
            None
        };
        
        Ok(ReturnStatement {
            value,
            span: self.create_span(span),
        })
    }

    /// Parse break statement
    fn parse_break_stmt(&mut self, pair: Pair<Rule>) -> Result<BreakStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        Ok(BreakStatement {
            span: self.create_span(span),
        })
    }

    /// Parse continue statement
    fn parse_continue_stmt(&mut self, pair: Pair<Rule>) -> Result<ContinueStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        Ok(ContinueStatement {
            span: self.create_span(span),
        })
    }

    /// Parse pass statement
    fn parse_pass_stmt(&mut self, pair: Pair<Rule>) -> Result<PassStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        Ok(PassStatement {
            span: self.create_span(span),
        })
    }

    /// Parse raise statement
    fn parse_raise_stmt(&mut self, pair: Pair<Rule>) -> Result<RaiseStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner();
        
        // The "raise" keyword is consumed by the grammar, so the first inner pair is the expression
        let value = self.parse_expression(inner.next().ok_or("Missing expression")?)?;
        
        Ok(RaiseStatement {
            value,
            span: self.create_span(span),
        })
    }

    /// Parse function declaration
    fn parse_function_decl(&mut self, pair: Pair<Rule>) -> Result<FunctionDecl, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        // Parse function name (first token after filtering whitespace)
        let name_pair = inner.next().ok_or_else(|| {
            self.add_parse_error(
                tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                "expected function name".to_string(),
                span,
            );
            "Missing function name"
        })?;
        let name = name_pair.as_str().to_string();
        
        // Validate function name
        if name.is_empty() {
            self.add_parse_error(
                tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                "function name cannot be empty".to_string(),
                name_pair.as_span(),
            );
        }
        
        // Parse generic parameters (optional)
        let mut generic_params = Vec::new();
        if let Some(next_token) = inner.clone().next() {
            if next_token.as_rule() == Rule::generic_params {
                // Consume the generic_params token
                let generic_params_pair = inner.next().ok_or_else(|| {
                    self.add_parse_error(
                        tjlang_diagnostics::ErrorCode::ParserInvalidFunction,
                        "malformed generic parameters".to_string(),
                        next_token.as_span(),
                    );
                    "Missing generic_params pair"
                })?;
                generic_params = self.parse_generic_params(generic_params_pair)?;
            }
        }
        
        // Parse parameter list (optional)
        let params = if let Some(params_pair) = inner.clone().next() {
            if params_pair.as_rule() == Rule::param_list {
                // Consume the param_list token
                let _ = inner.next();
                self.parse_param_list(params_pair)?
            } else {
                // No parameter list, skip to return type
                Vec::new()
            }
        } else {
            Vec::new()
        };
        
        // Parse return type (required)
        let return_type_pair = inner.next().ok_or_else(|| {
            self.add_parse_error(
                tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                format!("expected return type for function `{}`", name),
                span,
            );
            "Missing return type"
        })?;
        let return_type = if return_type_pair.as_rule() == Rule::type_ {
            self.parse_type(return_type_pair)?
        } else {
            self.add_parse_error(
                tjlang_diagnostics::ErrorCode::ParserInvalidType,
                format!("expected type, found {:?}", return_type_pair.as_rule()),
                return_type_pair.as_span(),
            );
            return Err(format!("Expected type_, got {:?}", return_type_pair.as_rule()).into());
        };
        
        // Parse function body (required)
        let body_pair = inner.next().ok_or_else(|| {
            self.add_parse_error(
                tjlang_diagnostics::ErrorCode::ParserExpectedToken,
                format!("expected function body for function `{}`", name),
                span,
            );
            "Missing function body"
        })?;
        let body = if body_pair.as_rule() == Rule::block {
            self.parse_block(body_pair)?
        } else {
            self.add_parse_error(
                tjlang_diagnostics::ErrorCode::ParserInvalidFunction,
                format!("expected block, found {:?}", body_pair.as_rule()),
                body_pair.as_span(),
            );
            return Err(format!("Expected block, got {:?}", body_pair.as_rule()).into());
        };
        
        // Add helpful warnings
        if params.is_empty() {
            self.add_parse_warning(
                tjlang_diagnostics::ErrorCode::ParserInvalidFunction,
                format!("function `{}` has no parameters - consider adding `()` for clarity", name),
                span,
            );
        }
        
        Ok(FunctionDecl {
                        name,
                        generic_params,
                        params,
                        return_type,
                        body,
                        span: self.create_span(span),
        })
    }
    
    /// Parse generic parameters
    fn parse_generic_params(&mut self, pair: Pair<Rule>) -> Result<Vec<GenericParam>, Box<dyn std::error::Error>> {
        let mut params = Vec::new();
        let inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        for param_pair in inner {
            if param_pair.as_rule() == Rule::generic_param {
                let param = self.parse_generic_param(param_pair)?;
                params.push(param);
            }
        }
        
        Ok(params)
    }
    
    /// Parse single generic parameter
    fn parse_generic_param(&mut self, pair: Pair<Rule>) -> Result<GenericParam, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let pair_clone = pair.clone();
        let mut inner = pair_clone.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        // First element should be the identifier (parameter name)
        let name_pair = inner.next().ok_or("Missing generic parameter name")?;
        let name = if name_pair.as_rule() == Rule::identifier {
            name_pair.as_str().to_string()
        } else {
            return Err(format!("Expected identifier, got {:?}", name_pair.as_rule()).into());
        };
        
        // Second element should be the identifier_list (bounds)
        let bounds_pair = inner.next().ok_or("Missing bounds")?;
        let bounds = if bounds_pair.as_rule() == Rule::identifier_list {
            self.parse_identifier_list(bounds_pair)?
        } else {
            return Err(format!("Expected identifier_list, got {:?}", bounds_pair.as_rule()).into());
        };
        
        Ok(GenericParam {
            name,
            bounds,
            span: self.create_span(span),
        })
    }
    
    /// Parse parameter list
    fn parse_param_list(&mut self, pair: Pair<Rule>) -> Result<Vec<Parameter>, Box<dyn std::error::Error>> {
        let mut params = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        while let Some(param_pair) = inner.next() {
            if param_pair.as_rule() == Rule::param {
                let param = self.parse_param(param_pair)?;
                params.push(param);
            } else if param_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }
        
        Ok(params)
    }
    
    /// Parse single parameter
    fn parse_param(&mut self, pair: Pair<Rule>) -> Result<Parameter, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        let name = inner.next().ok_or("Missing parameter name")?.as_str().to_string();
        
        let param_type = self.parse_type(inner.next().ok_or("Missing parameter type")?)?;
        
        Ok(Parameter {
            name,
            param_type,
            span: self.create_span(span),
        })
    }

    /// Parse collection literal
    fn parse_collection_literal(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let inner = pair.into_inner().next().ok_or("Empty collection literal")?;

        match inner.as_rule() {
            Rule::vec_literal => self.parse_vec_literal(inner),
            Rule::set_literal => self.parse_set_literal(inner),
            Rule::map_literal => self.parse_map_literal(inner),
            Rule::tuple_literal => self.parse_tuple_literal(inner),
            Rule::struct_literal => self.parse_struct_literal(inner),
            _ => Err("Unknown collection literal type".into())
        }
    }

    /// Parse vector literal
    fn parse_vec_literal(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut elements = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        while let Some(element_pair) = inner.next() {
            if element_pair.as_rule() == Rule::expression {
                let element = self.parse_expression(element_pair)?;
                elements.push(element);
            } else if element_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }

        Ok(Expression::VecLiteral {
            elements,
            span: self.create_span(span),
        })
    }

    /// Parse set literal
    fn parse_set_literal(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut elements = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        while let Some(element_pair) = inner.next() {
            if element_pair.as_rule() == Rule::expression {
                let element = self.parse_expression(element_pair)?;
                elements.push(element);
            } else if element_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }

        Ok(Expression::SetLiteral {
            elements,
            span: self.create_span(span),
        })
    }

    /// Parse map literal
    fn parse_map_literal(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut entries = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        while let Some(entry_pair) = inner.next() {
            if entry_pair.as_rule() == Rule::map_entry {
                let entry = self.parse_map_entry(entry_pair)?;
                entries.push(entry);
            } else if entry_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }

        Ok(Expression::MapLiteral {
            entries,
            span: self.create_span(span),
        })
    }

    /// Parse tuple literal
    fn parse_tuple_literal(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut elements = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        while let Some(element_pair) = inner.next() {
            if element_pair.as_rule() == Rule::expression {
                let element = self.parse_expression(element_pair)?;
                elements.push(element);
            } else if element_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }

        Ok(Expression::TupleLiteral {
            elements,
            span: self.create_span(span),
        })
    }

    /// Parse struct literal
    fn parse_struct_literal(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        // First element should be the struct name (identifier)
        let name_pair = inner.next().ok_or("Missing struct name in struct literal")?;
        let name = name_pair.as_str().to_string();
        
        // Parse field initializations
        let mut fields = Vec::new();
        while let Some(field_pair) = inner.next() {
            if field_pair.as_rule() == Rule::field_init {
                let field = self.parse_field_init(field_pair)?;
                fields.push(field);
            } else if field_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }
        
        Ok(Expression::StructLiteral {
            name,
            fields,
            span: self.create_span(span),
        })
    }

    /// Parse field initialization
    fn parse_field_init(&mut self, pair: Pair<Rule>) -> Result<FieldInit, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        // First element should be the field name (identifier)
        let name_pair = inner.next().ok_or("Missing field name in field initialization")?;
        let name = name_pair.as_str().to_string();
        
        // Skip the colon
        if let Some(colon_pair) = inner.next() {
            if colon_pair.as_str() != ":" {
                return Err("Expected ':' in field initialization".into());
            }
        }
        
        // Parse the expression value
        let value_pair = inner.next().ok_or("Missing field value in field initialization")?;
        let value = self.parse_expression(value_pair)?;
        
        Ok(FieldInit {
            name,
            value,
            span: self.create_span(span),
        })
    }

    /// Parse map entry
    fn parse_map_entry(&mut self, pair: Pair<Rule>) -> Result<MapEntry, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        let key = inner.next().ok_or("Missing map key")?;
        let key_expr = self.parse_expression(key)?;

        let value = inner.next().ok_or("Missing map value")?;
        let value_expr = self.parse_expression(value)?;

        Ok(MapEntry {
            key: key_expr,
            value: value_expr,
            span: self.create_span(span),
        })
    }

    /// Parse primary content (handles the inner content of a primary rule)
    fn parse_primary_content(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        match pair.as_rule() {
            Rule::spawn_expr => {
                // Handle spawn expressions - placeholder to avoid recursion
                Ok(Expression::Spawn { 
                    expression: Box::new(Expression::Literal(Literal::None)), 
                    span: self.create_span(pair.as_span()) 
                })
            }
            Rule::range_expr => {
                self.parse_range_expr(pair)
            }
            Rule::literal => {
                let literal = self.parse_literal(pair)?;
                Ok(Expression::Literal(literal))
            }
            Rule::identifier => {
                Ok(Expression::Variable(pair.as_str().to_string()))
            }
            Rule::collection_literal => {
                self.parse_collection_literal(pair)
            }
            Rule::lambda_expr => {
                self.parse_lambda_expr(pair)
            }
            Rule::expression => {
                // Handle parenthesized expressions: "(" ~ expression ~ ")"
                // For now, return a simple placeholder to avoid recursion
                Ok(Expression::Literal(Literal::None))
            }
            _ => {
                Err(format!("Unexpected primary content: {:?}", pair.as_rule()).into())
            }
        }
    }

    /// Parse postfix expression
    fn parse_postfix_expr(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        // Parse the primary expression
        let primary_pair = inner.next().ok_or("Missing primary expression")?;
        let mut expr = match primary_pair.as_rule() {
            Rule::primary => {
                // Extract the inner content of the primary rule
                let primary_inner = primary_pair.into_inner().next().ok_or("Empty primary rule")?;
                self.parse_primary_content(primary_inner)?
            }
            _ => {
                return Err(format!("Expected primary rule, got {:?}", primary_pair.as_rule()).into());
            }
        };
        
        // Apply postfix operations in order
        while let Some(suffix_pair) = inner.next() {
            match suffix_pair.as_rule() {
                Rule::call_suffix => {
                    expr = self.parse_call_suffix(expr, suffix_pair)?;
                }
                Rule::index_suffix => {
                    expr = self.parse_index_suffix(expr, suffix_pair)?;
                }
                Rule::member_suffix => {
                    expr = self.parse_member_suffix(expr, suffix_pair)?;
                }
                _ => {
                    return Err(format!("Unexpected postfix suffix: {:?}", suffix_pair.as_rule()).into());
                }
            }
        }
        
        Ok(expr)
    }

    /// Parse call suffix
    fn parse_call_suffix(&mut self, callee: Expression, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut args = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Parse arguments if present
        if let Some(arg_list_pair) = inner.next() {
            if arg_list_pair.as_rule() == Rule::argument_list {
                args = self.parse_argument_list(arg_list_pair)?;
            }
        }

        Ok(Expression::Call {
            callee: Box::new(callee),
            args,
            span: self.create_span(span),
        })
    }

    /// Parse index suffix
    fn parse_index_suffix(&mut self, target: Expression, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Parse index expression
        let index = self.parse_expression(inner.next().ok_or("Missing index expression")?)?;

        Ok(Expression::Index {
            target: Box::new(target),
            index: Box::new(index),
            span: self.create_span(span),
        })
    }

    /// Parse member suffix
    fn parse_member_suffix(&mut self, target: Expression, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Parse member name
        let member = inner.next().ok_or("Missing member name")?.as_str().to_string();

        Ok(Expression::Member {
            target: Box::new(target),
            member,
            span: self.create_span(span),
        })
    }

    /// Parse lambda expression
    fn parse_lambda_expr(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Parse parameters if present
        let mut params = Vec::new();
        if let Some(param_list_pair) = inner.next() {
            if param_list_pair.as_rule() == Rule::param_list {
                params = self.parse_param_list(param_list_pair)?;
            } else {
                // This is the body expression, not a parameter list
                let body = self.parse_expression(param_list_pair)?;
                return Ok(Expression::Lambda {
                    params,
                    body: Box::new(body),
                    span: self.create_span(span),
                });
            }
        }

        // Parse body expression
        let body = self.parse_expression(inner.next().ok_or("Missing lambda body")?)?;

        Ok(Expression::Lambda {
            params,
            body: Box::new(body),
            span: self.create_span(span),
        })
    }

    /// Parse range expression
    fn parse_range_expr(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let text = pair.as_str();
        let inclusive = text.contains("..=");
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Parse start value
        let start = self.parse_expression(inner.next().ok_or("Missing start value")?)?;

        // Parse end value (must exist for our current semantics)
        let end_pair = inner.next().ok_or("Missing end value")?;
        let end = self.parse_expression(end_pair)?;

        Ok(Expression::Range {
            start: Box::new(start),
            end: Box::new(end),
            inclusive,
            span: self.create_span(span),
        })
    }

    /// Parse argument list
    fn parse_argument_list(&mut self, pair: Pair<Rule>) -> Result<Vec<Expression>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        while let Some(arg_pair) = inner.next() {
            if arg_pair.as_rule() == Rule::expression {
                let arg = self.parse_expression(arg_pair)?;
                args.push(arg);
            } else if arg_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }

        Ok(args)
    }

    /// Parse union type
    fn parse_union_type(&mut self, pair: Pair<Rule>) -> Result<Type, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut types = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        while let Some(type_pair) = inner.next() {
            if type_pair.as_rule() == Rule::option_type {
                let option_type = self.parse_option_type(type_pair)?;
                types.push(option_type);
            } else if type_pair.as_str() == "|" {
                // Skip union operator
                continue;
            }
        }

        if types.len() == 1 {
            Ok(types.into_iter().next().unwrap())
        } else {
            Ok(Type::Union {
                types,
                span: self.create_span(span),
            })
        }
    }

    /// Parse option type
    fn parse_option_type(&mut self, pair: Pair<Rule>) -> Result<Type, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Check if this is an optional type
        let is_optional = if let Some(first) = inner.next() {
            if first.as_str() == "?" {
                true
            } else {
                // This is the function_type, not the optional marker
                let function_type = self.parse_function_type(first)?;
                return Ok(function_type);
            }
        } else {
            false
        };

        // Parse the function type
        let function_type = self.parse_function_type(inner.next().ok_or("Missing function type")?)?;

        if is_optional {
            Ok(Type::Option {
                inner: Box::new(function_type),
                span: self.create_span(span),
            })
        } else {
            Ok(function_type)
        }
    }

    /// Parse function type
    fn parse_function_type(&mut self, pair: Pair<Rule>) -> Result<Type, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Check if this is a function type with parameters
        if let Some(first) = inner.next() {
            if first.as_rule() == Rule::type_list {
                // This is a function type with parameters
                let param_types = self.parse_type_list(first)?;
                
                // Skip whitespace
                while let Some(next) = inner.next() {
                    if next.as_rule() != Rule::WHITESPACE {
                        // This should be the return type
                        let return_type = match next.as_rule() {
                            Rule::collection_type => {
                                self.parse_collection_type(next)?
                            }
                            Rule::primary_type => {
                                self.parse_primary_type(next)?
                            }
                            _ => return Err(format!("Expected collection_type or primary_type for return type, got {:?}", next.as_rule()).into())
                        };
                        
                        return Ok(Type::Function {
                            params: param_types,
                            return_type: Box::new(return_type),
                            span: self.create_span(span),
                        });
                    }
                }
                
                Err("Missing return type".into())
            } else if first.as_str() == "(" {
                // This is a function type with no parameters
                let param_types = Vec::new();
                
                // Skip closing parenthesis
                inner.next().ok_or("Missing closing parenthesis")?;
                
                // Skip arrow
                inner.next().ok_or("Missing arrow")?;
                
                // Parse return type
                let return_type = self.parse_type(inner.next().ok_or("Missing return type")?)?;
                
                Ok(Type::Function {
                    params: param_types,
                    return_type: Box::new(return_type),
                    span: self.create_span(span),
                })
            } else if first.as_rule() == Rule::function_type {
                // This is a nested function_type (like 'int' in '() -> int')
                self.parse_function_type(first)
            } else {
                // This is a collection_type or primary_type
                match first.as_rule() {
                    Rule::collection_type => {
                        self.parse_collection_type(first)
                    }
                    Rule::primary_type => {
                        self.parse_primary_type(first)
                    }
                    _ => Err(format!("Expected collection_type, primary_type, function_type, or type_list, got {:?}", first.as_rule()).into())
                }
            }
        } else {
            Err("Empty function type".into())
        }
    }

    /// Parse collection type
    fn parse_collection_type(&mut self, pair: Pair<Rule>) -> Result<Type, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let inner = pair.into_inner().next().ok_or("Empty collection type")?;

        match inner.as_rule() {
            Rule::vec_type => {
                let element_type = self.parse_type(inner.into_inner().next().ok_or("Missing vec element type")?)?;
                Ok(Type::Vec {
                    element_type: Box::new(element_type),
                    span: self.create_span(span),
                })
            }
            Rule::set_type => {
                let element_type = self.parse_type(inner.into_inner().next().ok_or("Missing set element type")?)?;
                Ok(Type::Set {
                    element_type: Box::new(element_type),
                    span: self.create_span(span),
                })
            }
            Rule::map_type => {
                let mut it = inner.into_inner();
                let key_type = self.parse_type(it.next().ok_or("Missing map key type")?)?;
                let value_type = self.parse_type(it.next().ok_or("Missing map value type")?)?;
                Ok(Type::Map { key_type: Box::new(key_type), value_type: Box::new(value_type), span: self.create_span(span) })
            }
            Rule::tuple_type => {
                let mut types = Vec::new();
                for type_pair in inner.into_inner() {
                    let ty = self.parse_type(type_pair)?;
                    types.push(ty);
                }
                Ok(Type::Tuple { types, span: self.create_span(span) })
            }
            _ => Err(format!("Expected collection type, got {:?}", inner.as_rule()).into())
        }
    }

    /// Parse primary type
    fn parse_primary_type(&mut self, pair: Pair<Rule>) -> Result<Type, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let inner = pair.into_inner().next().ok_or("Empty primary type")?;

        match inner.as_rule() {
            Rule::primitive_type => {
                let type_str = inner.as_str();
                let primitive_type = match type_str {
                    "int" => PrimitiveType::Int,
                    "float" => PrimitiveType::Float,
                    "bool" => PrimitiveType::Bool,
                    "str" => PrimitiveType::Str,
                    "any" => PrimitiveType::Any,
                    _ => return Err(format!("Unknown primitive type: {}", type_str).into()),
                };
                Ok(Type::Primitive(primitive_type))
            }
            Rule::identifier => {
                let name = inner.as_str().to_string();
                // Check if there are type parameters
                if let Some(type_params_pair) = inner.into_inner().next() {
                    if type_params_pair.as_rule() == Rule::type_params {
                        let type_params = self.parse_type_params(type_params_pair)?;
                        
                        // Special handling for Map type
                        if name == "Map" && type_params.len() == 2 {
                            Ok(Type::Map {
                                key_type: Box::new(type_params[0].clone()),
                                value_type: Box::new(type_params[1].clone()),
                                span: self.create_span(span),
                            })
                        } else {
                            Ok(Type::Generic {
                                name,
                                type_args: type_params,
                                span: self.create_span(span),
                            })
                        }
                    } else {
                        Ok(Type::Identifier(name))
                    }
                } else {
                    Ok(Type::Identifier(name))
                }
            }
            Rule::result_type => {
                let mut inner = inner.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                // Skip "Result"
                inner.next().ok_or("Missing Result keyword")?;
                // Skip "<"
                inner.next().ok_or("Missing opening angle bracket")?;
                let ok_type = self.parse_type(inner.next().ok_or("Missing Result ok type")?)?;
                // Skip ","
                inner.next().ok_or("Missing comma")?;
                let err_type = self.parse_type(inner.next().ok_or("Missing Result error type")?)?;
                // Skip ">"
                inner.next().ok_or("Missing closing angle bracket")?;
                Ok(Type::Result {
                    ok_type: Box::new(ok_type),
                    error_type: Box::new(err_type),
                    span: self.create_span(span),
                })
            }
            Rule::option_wrapper => {
                let mut inner = inner.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                // Skip "Option"
                inner.next().ok_or("Missing Option keyword")?;
                // Skip "<"
                inner.next().ok_or("Missing opening angle bracket")?;
                let inner_type = self.parse_type(inner.next().ok_or("Missing Option inner type")?)?;
                // Skip ">"
                inner.next().ok_or("Missing closing angle bracket")?;
                Ok(Type::Option {
                    inner: Box::new(inner_type),
                    span: self.create_span(span),
                })
            }
            _ => Err(format!("Expected primary type, got {:?}", inner.as_rule()).into())
        }
    }

    /// Parse type list
    fn parse_type_list(&mut self, pair: Pair<Rule>) -> Result<Vec<Type>, Box<dyn std::error::Error>> {
        let mut types = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        while let Some(type_pair) = inner.next() {
            if type_pair.as_rule() == Rule::type_ {
                let type_ = self.parse_type(type_pair)?;
                types.push(type_);
            } else if type_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }

        Ok(types)
    }

    /// Parse type parameters
    fn parse_type_params(&mut self, pair: Pair<Rule>) -> Result<Vec<Type>, Box<dyn std::error::Error>> {
        let mut types = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        while let Some(type_pair) = inner.next() {
            if type_pair.as_rule() == Rule::type_ {
                let type_ = self.parse_type(type_pair)?;
                types.push(type_);
            } else if type_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }

        Ok(types)
    }

    /// Parse type declaration
    fn parse_type_decl(&mut self, pair: Pair<Rule>) -> Result<TypeDecl, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // The grammar consumes literals; we expect: identifier, type_
        let name = inner.next().ok_or("Missing type name")?.as_str().to_string();
        let type_pair = inner.next().ok_or("Missing type alias")?;
        let type_alias = self.parse_type(type_pair)?;

        Ok(TypeDecl { name, type_alias, span: self.create_span(span) })
    }

    /// Parse struct declaration
    fn parse_struct_decl(&mut self, pair: Pair<Rule>) -> Result<StructDecl, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Expect: identifier, then zero or more field_decl entries (grammar enforces at least one)
        let name = inner.next().ok_or("Missing struct name")?.as_str().to_string();
        let mut fields = Vec::new();
        for p in inner {
            if p.as_rule() == Rule::field_decl {
                fields.push(self.parse_field_decl(p)?);
            }
        }

        Ok(StructDecl { name, fields, span: self.create_span(span) })
    }

    /// Parse field declaration
    fn parse_field_decl(&mut self, pair: Pair<Rule>) -> Result<FieldDecl, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Expect: identifier then type_
        let name = inner.next().ok_or("Missing field name")?.as_str().to_string();
        let ty_pair = inner.next().ok_or("Missing field type")?;
        let field_type = self.parse_type(ty_pair)?;

        Ok(FieldDecl {
            name,
            field_type,
            span: self.create_span(span),
        })
    }

    /// Parse enum declaration
    fn parse_enum_decl(&mut self, pair: Pair<Rule>) -> Result<EnumDecl, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Skip "enum" keyword
        inner.next().ok_or("Missing enum keyword")?;

        // Parse enum name
        let name = inner.next().ok_or("Missing enum name")?.as_str().to_string();

        // Parse identifier generic param names if present
        let mut type_params = Vec::new();
        if let Some(next_pair) = inner.next() {
            if next_pair.as_rule() == Rule::type_param_list {
                let mut names = next_pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                while let Some(tok) = names.next() {
                    if tok.as_rule() == Rule::identifier {
                        type_params.push(tok.as_str().to_string());
                    }
                }
            } else {
                // put it back by handling downstream
                // next_pair should be the first enum body element "{...}"
                // We proceed using this as the first element when iterating further
                // To do so, create an iterator starting from this pair
                let mut rest = std::iter::once(next_pair).chain(inner);
                // Expect variants list between braces handled by grammar; just iterate enum_variant entries
                let mut variants = Vec::new();
                while let Some(variant_pair) = rest.next() {
                    if variant_pair.as_rule() == Rule::enum_variant {
                        variants.push(self.parse_enum_variant(variant_pair)?);
                    }
                }
                return Ok(EnumDecl { name, type_params, variants, span: self.create_span(span) });
            }
        }

        // Collect variants
        let mut variants = Vec::new();
        for variant_pair in inner {
            if variant_pair.as_rule() == Rule::enum_variant {
                variants.push(self.parse_enum_variant(variant_pair)?);
            }
        }

        Ok(EnumDecl { name, type_params, variants, span: self.create_span(span) })
    }

    /// Parse enum variant
    fn parse_enum_variant(&mut self, pair: Pair<Rule>) -> Result<EnumVariant, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        // Parse variant name
        let name = inner.next().ok_or("Missing variant name")?.as_str().to_string();
        
        // Parse fields if present
        let mut fields = Vec::new();
        if let Some(fields_pair) = inner.next() {
            if fields_pair.as_rule() == Rule::variant_fields {
                fields = self.parse_variant_fields(fields_pair)?;
            }
        }
        
        Ok(EnumVariant {
            name,
            fields,
            span: self.create_span(span),
        })
    }

    /// Parse variant fields
    fn parse_variant_fields(&mut self, pair: Pair<Rule>) -> Result<Vec<Type>, Box<dyn std::error::Error>> {
        let mut fields = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        while let Some(field_pair) = inner.next() {
            if field_pair.as_rule() == Rule::type_ {
                let field_type = self.parse_type(field_pair)?;
                fields.push(field_type);
            } else if field_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }
        
        Ok(fields)
    }

    /// Parse interface declaration
    fn parse_interface_decl(&mut self, pair: Pair<Rule>) -> Result<InterfaceDecl, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Debug: print all inner pairs
        let inner_pairs: Vec<_> = inner.clone().collect();
        // println!("DEBUG: Interface declaration inner pairs:");
        // for (i, p) in inner_pairs.iter().enumerate() {
        //     println!("  {}: Rule={:?}, Content='{}'", i, p.as_rule(), p.as_str());
        // }

        // Parse interface name (first element)
        let name_pair = inner.next().ok_or("Missing interface name")?;
        let name = if name_pair.as_rule() == Rule::interface_name {
            // Extract the identifier from interface_name
            let mut name_inner = name_pair.into_inner();
            let identifier_pair = name_inner.next().ok_or("Missing identifier in interface_name")?;
            identifier_pair.as_str().to_string()
        } else {
            name_pair.as_str().to_string()
        };
        // println!("DEBUG: Parsed interface name: '{}'", name);

        // Optional generic param names
        if let Some(next) = inner.clone().next() {
            if next.as_rule() == Rule::type_param_list {
                // consume
                let _ = inner.next();
            }
        }

        // Parse extends clause if present
        let mut extends = Vec::new();
        if let Some(next_pair) = inner.clone().next() {
            if next_pair.as_rule() == Rule::interface_extends {
                // Parse the interface_extends rule
                let _ = inner.next(); // consume the interface_extends pair
                let mut extends_inner = next_pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                
                // Skip the "extends" keyword and get the identifier_list
                while let Some(extends_child) = extends_inner.next() {
                    if extends_child.as_rule() == Rule::identifier_list {
                        extends = self.parse_identifier_list(extends_child)?;
                        break;
                    }
                }
            }
        }

        // Methods
        let mut methods = Vec::new();
        for p in inner { if p.as_rule() == Rule::method_sig { methods.push(self.build_method_sig(p)?); } }

        Ok(InterfaceDecl { name, extends, methods, span: self.create_span(span) })
    }

    fn build_method_sig(&mut self, pair: Pair<Rule>) -> Result<MethodSig, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        // Parse method name (can be identifier or operator_symbol)
        let name_pair = inner.next().ok_or("Missing method name")?;
        let name = match name_pair.as_rule() {
            Rule::identifier | Rule::operator_symbol => name_pair.as_str().to_string(),
            _ => return Err(format!("Expected identifier or operator_symbol, got {:?}", name_pair.as_rule()).into()),
        };
        let mut params = Vec::new();

        // Next can be param_list or ARROW
        let next = inner.next().ok_or("Missing method signature tail")?;
        let after_arrow_pair = if next.as_rule() == Rule::param_list {
            params = self.parse_param_list(next)?;
            // Expect ARROW next
            let arrow = inner.next().ok_or("Missing arrow in method signature")?;
            if arrow.as_rule() != Rule::ARROW { return Err("Expected arrow in method signature".into()); }
            inner.next().ok_or("Missing return type in method signature")?
        } else {
            // Must be ARROW directly
            if next.as_rule() != Rule::ARROW { return Err("Expected arrow or param list in method signature".into()); }
            inner.next().ok_or("Missing return type in method signature")?
        };

        let return_type = self.parse_type(after_arrow_pair)?;
        Ok(MethodSig { name, params, return_type, span: self.create_span(span) })
    }

    /// Parse implementation block
    fn parse_impl_block(&mut self, pair: Pair<Rule>) -> Result<ImplBlock, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // The grammar yields: impl_trait_name, impl_type_name, then method_decl*
        // The "impl" keyword and ":" separator are consumed by the grammar but don't appear as separate pairs
        let trait_name = inner.next().ok_or("Missing trait name")?.as_str().to_string();
        let type_name = inner.next().ok_or("Missing type name")?.as_str().to_string();

        let mut methods = Vec::new();
        for p in inner {
            if p.as_rule() == Rule::method_decl { 
                methods.push(self.parse_method_decl(p)?); 
            }
        }

        Ok(ImplBlock { trait_name, type_name, methods, span: self.create_span(span) })
    }

    /// Parse method declaration
    fn parse_method_decl(&mut self, pair: Pair<Rule>) -> Result<MethodDecl, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);

        // Parse method name (can be identifier or operator_symbol)
        let name_pair = inner.next().ok_or("Missing method name")?;
        let name = match name_pair.as_rule() {
            Rule::identifier | Rule::operator_symbol => name_pair.as_str().to_string(),
            _ => return Err(format!("Expected identifier or operator_symbol, got {:?}", name_pair.as_rule()).into()),
        };

        // Next can be param_list or ARROW
        let mut params = Vec::new();
        let next = inner.next().ok_or("Missing method declaration tail")?;
        let after_arrow_pair = if next.as_rule() == Rule::param_list {
            params = self.parse_param_list(next)?;
            // Expect ARROW
            let arrow = inner.next().ok_or("Missing arrow in method declaration")?;
            if arrow.as_rule() != Rule::ARROW { return Err("Expected arrow in method declaration".into()); }
            inner.next().ok_or("Missing return type in method declaration")?
        } else {
            if next.as_rule() != Rule::ARROW { return Err("Expected arrow or param list in method declaration".into()); }
            inner.next().ok_or("Missing return type in method declaration")?
        };

        // Parse return type
        let return_type = self.parse_type(after_arrow_pair)?;

        // Parse body
        let body = self.parse_block(inner.next().ok_or("Missing method body")?)?;

        Ok(MethodDecl {
            name,
            params,
            return_type,
            body,
            span: self.create_span(span),
        })
    }

    /// Parse identifier list
    fn parse_identifier_list(&mut self, pair: Pair<Rule>) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let mut identifiers = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        while let Some(ident_pair) = inner.next() {
            if ident_pair.as_rule() == Rule::identifier {
                identifiers.push(ident_pair.as_str().to_string());
            } else if ident_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }
        
        Ok(identifiers)
    }

    /// Parse export declaration
    fn parse_export_decl(&mut self, pair: Pair<Rule>) -> Result<ExportDecl, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let inner = pair.into_inner().next().ok_or("Empty export declaration")?;
        
        match inner.as_rule() {
            Rule::function_decl => {
                let func_decl = self.parse_function_decl(inner)?;
                Ok(ExportDecl::Declaration(Declaration::Function(func_decl)))
            }
            Rule::type_decl => {
                let type_decl = self.parse_type_decl(inner)?;
                Ok(ExportDecl::Declaration(Declaration::Type(type_decl)))
            }
            Rule::interface_decl => {
                let interface_decl = self.parse_interface_decl(inner)?;
                Ok(ExportDecl::Declaration(Declaration::Interface(interface_decl)))
            }
            Rule::identifier => {
                let name = inner.as_str().to_string();
                Ok(ExportDecl::Identifier(name))
            }
            Rule::identifier_list => {
                let identifiers = self.parse_identifier_list(inner)?;
                Ok(ExportDecl::IdentifierList(identifiers))
            }
            _ => return Err(format!("Expected function_decl, type_decl, interface_decl, identifier, or identifier_list in export, got {:?}", inner.as_rule()).into()),
        }
    }

    /// Create a SourceSpan from a pest span
    fn create_span(&self, span: pest::Span) -> tjlang_ast::SourceSpan {
        let mut files = Files::new();
        let file_id = files.add("input.tj", "");
        tjlang_ast::SourceSpan {
            file_id,
            span: codespan::Span::new(
                codespan::ByteIndex(span.start() as u32),
                codespan::ByteIndex(span.end() as u32),
            ),
        }
    }

    /// Create a DiagnosticSourceSpan from a pest span
    fn create_diagnostic_span(&self, span: pest::Span) -> DiagnosticSourceSpan {
        let mut files = Files::new();
        let file_id = files.add("input.tj", "");
        DiagnosticSourceSpan {
            file_id,
            span: codespan::Span::new(
                codespan::ByteIndex(span.start() as u32),
                codespan::ByteIndex(span.end() as u32),
            ),
        }
    }

    fn parse_fstring_parts(&mut self, pair: Pair<Rule>) -> Result<Vec<tjlang_ast::FStringPart>, Box<dyn std::error::Error>> {
        let mut parts = Vec::new();
        
        for inner in pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE) {
            match inner.as_rule() {
                Rule::fstring_content => {
                    // fstring_content contains either fstring_text or fstring_expression
                    let content_inner = inner.into_inner().next().ok_or("Empty fstring_content")?;
                    match content_inner.as_rule() {
                        Rule::fstring_text => {
                            let text = content_inner.as_str().to_string();
                            if !text.is_empty() {
                                parts.push(tjlang_ast::FStringPart::Text(text));
                            }
                        }
                        Rule::fstring_expression => {
                            // fstring_expression contains an expression rule
                            let expr_inner = content_inner.into_inner().next().ok_or("Empty fstring_expression")?;
                            let expr = self.parse_expression(expr_inner)?;
                            parts.push(tjlang_ast::FStringPart::Expression(Box::new(expr)));
                        }
                        _ => return Err(format!("Unexpected rule in fstring_content: {:?}", content_inner.as_rule()).into()),
                    }
                }
                _ => return Err(format!("Unexpected rule in f-string: {:?}", inner.as_rule()).into()),
            }
        }
        
        Ok(parts)
    }
}
