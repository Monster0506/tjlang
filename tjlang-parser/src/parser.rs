//! Pest-based parser for TJLang
//! This replaces the recursive descent parser with a more robust pest-based solution

use pest::Parser;
use pest::iterators::Pair;
use pest_derive::Parser;
use tjlang_ast::*;
use tjlang_diagnostics::{DiagnosticCollection, SourceSpan};
use codespan::Files;

// Import the generated parser
#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct TJLangPestParser;

// The Rule enum is generated by the derive macro and is in the same scope

/// Main parser struct using pest
pub struct PestParser {
    pub diagnostics: DiagnosticCollection,
}

impl PestParser {
    /// Create a new pest parser
    pub fn new() -> Self {
        Self {
            diagnostics: DiagnosticCollection::new(),
        }
    }






    /// Parse TJLang source code
    pub fn parse(&mut self, source: &str) -> Result<Program, Box<dyn std::error::Error>> {
        // Parse using pest
        let pairs = TJLangPestParser::parse(Rule::program, source)
            .map_err(|e| format!("Parse error: {}", e))?;

        
        // Convert pest pairs to AST
        let program = self.parse_program(pairs, source)?;
        Ok(program)
    }

    /// Parse program from pest pairs
    fn parse_program(&mut self, mut pairs: pest::iterators::Pairs<Rule>, _source: &str) -> Result<Program, Box<dyn std::error::Error>> {
        let program_pair = pairs.next().ok_or("No program found")?;
        let span = program_pair.as_span();
        
        let mut units = Vec::new();
        for pair in program_pair.into_inner() {
            match pair.as_rule() {
                Rule::program_unit => {
                    let inner = pair.into_inner().next().ok_or("Empty program unit")?;
                    match inner.as_rule() {
                        Rule::statement => {
                            if let Some(statement) = self.parse_statement(inner)? {
                                // For now, wrap statements in a simple program unit
                                // In a real implementation, we'd have a proper main function
                                units.push(ProgramUnit::Declaration(Declaration::Variable(VariableDecl {
                                    name: "main".to_string(),
                                    var_type: Type::Primitive(PrimitiveType::Any),
                                    value: Expression::Literal(Literal::None),
                                    span: self.create_span(span),
                                })));
                            }
                        }
                        Rule::function_decl => {
                            let func_decl = self.parse_function_decl(inner)?;
                            units.push(ProgramUnit::Declaration(Declaration::Function(func_decl)));
                        }
                        _ => {}
                    }
                }
                Rule::EOI => break, // End of input
                _ => {} // Skip other rules
            }
        }

        // If no units were parsed, create a dummy one for empty programs
        if units.is_empty() {
            units.push(ProgramUnit::Declaration(Declaration::Variable(VariableDecl {
                name: "main".to_string(),
                var_type: Type::Primitive(PrimitiveType::Any),
                value: Expression::Literal(Literal::None),
                span: self.create_span(span),
            })));
        }

        let program = Program {
            units,
            span: self.create_span(span),
        };
        
        Ok(program)
    }

    /// Parse statement from pest pair
    fn parse_statement(&mut self, pair: Pair<Rule>) -> Result<Option<Statement>, Box<dyn std::error::Error>> {
        // println!("Parsing statement rule: {:?}, content: '{}'", pair.as_rule(), pair.as_str());
        match pair.as_rule() {
            Rule::statement => {
                let inner = pair.into_inner().next().ok_or("Empty statement")?;
                // println!("  -> inner statement rule: {:?}, content: '{}'", inner.as_rule(), inner.as_str());
                match inner.as_rule() {
                    Rule::variable_decl => {
                        let var_decl = self.parse_variable_decl(inner)?;
                        Ok(Some(Statement::Variable(var_decl)))
                    }
                    Rule::expression => {
                        let expr = self.parse_expression(inner)?;
                        Ok(Some(Statement::Expression(expr)))
                    }
                    Rule::block => {
                        let block = self.parse_block(inner)?;
                        Ok(Some(Statement::Block(block)))
                    }
                    Rule::if_stmt => {
                        let if_stmt = self.parse_if_stmt(inner)?;
                        Ok(Some(Statement::If(if_stmt)))
                    }
                    Rule::while_stmt => {
                        let while_stmt = self.parse_while_stmt(inner)?;
                        Ok(Some(Statement::While(while_stmt)))
                    }
                    Rule::for_stmt => {
                        let for_stmt = self.parse_for_stmt(inner)?;
                        Ok(Some(Statement::For(for_stmt)))
                    }
                    Rule::return_stmt => {
                        let return_stmt = self.parse_return_stmt(inner)?;
                        Ok(Some(Statement::Return(return_stmt)))
                    }
                    Rule::break_stmt => {
                        let break_stmt = self.parse_break_stmt(inner)?;
                        Ok(Some(Statement::Break(break_stmt)))
                    }
                    Rule::continue_stmt => {
                        let continue_stmt = self.parse_continue_stmt(inner)?;
                        Ok(Some(Statement::Continue(continue_stmt)))
                    }
                    Rule::pass_stmt => {
                        let pass_stmt = self.parse_pass_stmt(inner)?;
                        Ok(Some(Statement::Pass(pass_stmt)))
                    }
                    Rule::raise_stmt => {
                        let raise_stmt = self.parse_raise_stmt(inner)?;
                        Ok(Some(Statement::Raise(raise_stmt)))
                    }
                    _ => Ok(None)
                }
            }
            _ => Ok(None)
        }
    }

    /// Parse block
    fn parse_block(&mut self, pair: Pair<Rule>) -> Result<Block, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut statements = Vec::new();
        
        for inner_pair in pair.into_inner() {
            if let Some(statement) = self.parse_statement(inner_pair)? {
                statements.push(statement);
            }
        }
        
        Ok(Block {
            statements,
            span: self.create_span(span),
        })
    }

        /// Parse variable declaration
        fn parse_variable_decl(&mut self, pair: Pair<Rule>) -> Result<VariableDecl, Box<dyn std::error::Error>> {
            let span = pair.as_span();
            let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
            
            let name_pair = inner.next().ok_or("Missing variable name")?;
            let name = name_pair.as_str().to_string();
            
            // Note: colon ":" is a literal in the grammar and not included in the parse tree
            
            let type_pair = inner.next().ok_or("Missing type")?;
            let type_ = self.parse_type(type_pair)?;
            
            // Note: equals "=" is a literal in the grammar and not included in the parse tree
            
            let expr_pair = inner.next().ok_or("Missing expression")?;
            let expression = self.parse_expression(expr_pair)?;
            
            Ok(VariableDecl {
                name,
                var_type: type_,
                value: expression,
                span: self.create_span(span),
            })
        }

    /// Parse type
    fn parse_type(&mut self, pair: Pair<Rule>) -> Result<Type, Box<dyn std::error::Error>> {
        match pair.as_rule() {
            Rule::type_ => {
                // For the top-level type rule, parse its inner content
                let inner = pair.into_inner().next().ok_or("Empty type")?;
                self.parse_type(inner)
            }
            Rule::primitive_type => {
                let type_str = pair.as_str();
                let primitive_type = match type_str {
                    "int" => PrimitiveType::Int,
                    "float" => PrimitiveType::Float,
                    "bool" => PrimitiveType::Bool,
                    "str" => PrimitiveType::Str,
                    "any" => PrimitiveType::Any,
                    _ => return Err(format!("Unknown primitive type: {}", type_str).into()),
                };
                Ok(Type::Primitive(primitive_type))
            }
            Rule::identifier => {
                let name = pair.as_str().to_string();
                Ok(Type::Identifier(name))
            }
            _ => Err(format!("Expected type, got {:?}", pair.as_rule()).into())
        }
    }

    /// Parse expression with proper precedence
    fn parse_expression(&mut self, pair: Pair<Rule>) -> Result<Expression, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        
        match pair.as_rule() {
            Rule::expression => {
                // For the top-level expression rule, just parse its inner content
                let inner = pair.into_inner().next().ok_or("Empty expression")?;
                self.parse_expression(inner)
            }
            Rule::assignment => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                
                if let Some(assign_pair) = inner.next() {
                    if assign_pair.as_str() == "=" {
                        let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                        // For now, just return the right side since we don't have assignment expressions in AST yet
                        Ok(right)
                    } else {
                        Ok(left)
                    }
                } else {
                    Ok(left)
                }
            }
            Rule::or_expr => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                
                while let Some(op_pair) = inner.next() {
                    if op_pair.as_str() == "or" {
                        let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                        left = Expression::Binary {
                            left: Box::new(left),
                            operator: BinaryOperator::Or,
                            right: Box::new(right),
                            span: self.create_span(span),
                        };
                    } else {
                        // This should be the next expression
                        left = self.parse_expression(op_pair)?;
                    }
                }
                Ok(left)
            }
            Rule::and_expr => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                
                while let Some(op_pair) = inner.next() {
                    if op_pair.as_str() == "and" {
                        let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                        left = Expression::Binary {
                            left: Box::new(left),
                            operator: BinaryOperator::And,
                            right: Box::new(right),
                            span: self.create_span(span),
                        };
                    } else {
                        left = self.parse_expression(op_pair)?;
                    }
                }
                Ok(left)
            }
            Rule::equality => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                
                while let Some(op_pair) = inner.next() {
                    match op_pair.as_str() {
                        "==" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Equal,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        "!=" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::NotEqual,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        _ => {
                            left = self.parse_expression(op_pair)?;
                        }
                    }
                }
                Ok(left)
            }
            Rule::relational => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                
                while let Some(op_pair) = inner.next() {
                    match op_pair.as_str() {
                        "<" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::LessThan,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        ">" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::GreaterThan,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        "<=" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::LessThanEqual,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        ">=" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::GreaterThanEqual,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        _ => {
                            left = self.parse_expression(op_pair)?;
                        }
                    }
                }
                Ok(left)
            }
            Rule::additive => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                
                while let Some(op_pair) = inner.next() {
                    match op_pair.as_str() {
                        "+" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Add,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        "-" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Subtract,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        _ => {
                            left = self.parse_expression(op_pair)?;
                        }
                    }
                }
                Ok(left)
            }
            Rule::multiplicative => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                let mut left = self.parse_expression(inner.next().ok_or("Missing left operand")?)?;
                
                while let Some(op_pair) = inner.next() {
                    match op_pair.as_str() {
                        "*" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Multiply,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        "/" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Divide,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        "%" => {
                            let right = self.parse_expression(inner.next().ok_or("Missing right operand")?)?;
                            left = Expression::Binary {
                                left: Box::new(left),
                                operator: BinaryOperator::Modulo,
                                right: Box::new(right),
                                span: self.create_span(span),
                            };
                        }
                        _ => {
                            left = self.parse_expression(op_pair)?;
                        }
                    }
                }
                Ok(left)
            }
            Rule::unary => {
                let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
                
                if let Some(op_pair) = inner.next() {
                    match op_pair.as_str() {
                        "-" => {
                            let operand = self.parse_expression(inner.next().ok_or("Missing operand")?)?;
                            Ok(Expression::Unary {
                                operator: UnaryOperator::Negate,
                                operand: Box::new(operand),
                                span: self.create_span(span),
                            })
                        }
                        "!" => {
                            let operand = self.parse_expression(inner.next().ok_or("Missing operand")?)?;
                            Ok(Expression::Unary {
                                operator: UnaryOperator::Not,
                                operand: Box::new(operand),
                                span: self.create_span(span),
                            })
                        }
                        _ => {
                            // No unary operator, parse as primary
                            self.parse_expression(op_pair)
                        }
                    }
                } else {
                    // No unary operator, parse as primary
                    Err("Missing unary expression".into())
                }
            }
            Rule::primary => {
                let inner = pair.into_inner().next().ok_or("Empty primary expression")?;
                match inner.as_rule() {
                    Rule::literal => {
                        let literal = self.parse_literal(inner)?;
                        Ok(Expression::Literal(literal))
                    }
                    Rule::identifier => {
                        let name = inner.as_str().to_string();
                        Ok(Expression::Variable(name))
                    }
                    Rule::expression => {
                        // This is for parenthesized expressions - parse the inner expression
                        let inner_expr = inner.into_inner().next().ok_or("Empty parenthesized expression")?;
                        self.parse_expression(inner_expr)
                    }
                    _ => Err(format!("Expected primary expression, got {:?}", inner.as_rule()).into())
                }
            }
            Rule::WHITESPACE => {
                // Skip whitespace tokens - they should be handled automatically by pest
                // This shouldn't happen, but if it does, just skip it
                Err("Unexpected whitespace in expression".into())
            }
            _ => Err(format!("Expected expression, got {:?}", pair.as_rule()).into())
        }
    }

    /// Parse literal
    fn parse_literal(&mut self, pair: Pair<Rule>) -> Result<Literal, Box<dyn std::error::Error>> {
        let inner = pair.into_inner().next().ok_or("Empty literal")?;
        
        // println!("        Parsing literal inner: {:?}, content: '{}'", inner.as_rule(), inner.as_str());
        
        match inner.as_rule() {
                Rule::integer_literal => {
                    let content = inner.as_str().trim();
                    let value = content.parse::<i64>()
                        .map_err(|e| format!("Invalid integer: {} (content: '{}')", e, content))?;
                    Ok(Literal::Int(value))
                }
            Rule::float_literal => {
                let value = inner.as_str().parse::<f64>()
                    .map_err(|e| format!("Invalid float: {}", e))?;
                Ok(Literal::Float(value))
            }
            Rule::string_literal => {
                let value = inner.as_str().to_string();
                // Remove quotes
                let value = value.trim_start_matches('"').trim_end_matches('"').to_string();
                Ok(Literal::String(value))
            }
            Rule::boolean_literal => {
                let value = inner.as_str() == "true";
                Ok(Literal::Bool(value))
            }
            Rule::none_literal => {
                Ok(Literal::None)
            }
            _ => Err(format!("Expected literal, got {:?}", inner.as_rule()).into())
        }
    }

    /// Parse if statement
    fn parse_if_stmt(&mut self, pair: Pair<Rule>) -> Result<IfStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner();
        
        // Skip "if" keyword
        inner.next().ok_or("Missing 'if' keyword")?;
        
        let condition = self.parse_expression(inner.next().ok_or("Missing condition")?)?;
        let then_block = self.parse_block(inner.next().ok_or("Missing then block")?)?;
        
        // Parse elif branches
        let mut elif_branches = Vec::new();
        while let Some(branch_pair) = inner.next() {
            if branch_pair.as_rule() == Rule::elif_branch {
                let branch_span = branch_pair.as_span();
                let mut branch_inner = branch_pair.into_inner();
                
                // Skip "elif" keyword
                branch_inner.next().ok_or("Missing 'elif' keyword")?;
                
                let branch_condition = self.parse_expression(branch_inner.next().ok_or("Missing elif condition")?)?;
                let branch_block = self.parse_block(branch_inner.next().ok_or("Missing elif block")?)?;
                
                elif_branches.push(ElifBranch {
                    condition: branch_condition,
                    block: branch_block,
                    span: self.create_span(branch_span),
                });
            } else {
                // This should be the else branch
                break;
            }
        }
        
        // Parse else branch if present
        let else_block = if let Some(else_pair) = inner.next() {
            if else_pair.as_rule() == Rule::else_branch {
                let mut else_inner = else_pair.into_inner();
                
                // Skip "else" keyword
                else_inner.next().ok_or("Missing 'else' keyword")?;
                
                Some(self.parse_block(else_inner.next().ok_or("Missing else block")?)?)
            } else {
                None
            }
        } else {
            None
        };
        
        Ok(IfStatement {
            condition,
            then_block,
            elif_branches,
            else_block,
            span: self.create_span(span),
        })
    }

    /// Parse while statement
    fn parse_while_stmt(&mut self, pair: Pair<Rule>) -> Result<WhileStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner();
        
        // Skip "while" keyword
        inner.next().ok_or("Missing 'while' keyword")?;
        
        let condition = self.parse_expression(inner.next().ok_or("Missing condition")?)?;
        let body = self.parse_block(inner.next().ok_or("Missing body")?)?;
        
        Ok(WhileStatement {
            condition,
            body,
            span: self.create_span(span),
        })
    }

    /// Parse for statement
    fn parse_for_stmt(&mut self, pair: Pair<Rule>) -> Result<ForStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        // The grammar produces: identifier, type_, expression, block
        // (the literal tokens are consumed by the grammar)
        let var_name = inner.next().ok_or("Missing variable name")?.as_str().trim().to_string();
        let var_type = self.parse_type(inner.next().ok_or("Missing variable type")?)?;
        let iterable = self.parse_expression(inner.next().ok_or("Missing iterable")?)?;
        let body = self.parse_block(inner.next().ok_or("Missing body")?)?;
        
        Ok(ForStatement {
            var_name,
            var_type,
            iterable,
            body,
            span: self.create_span(span),
        })
    }

    /// Parse return statement
    fn parse_return_stmt(&mut self, pair: Pair<Rule>) -> Result<ReturnStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner();
        
        // Skip "return" keyword
        inner.next().ok_or("Missing 'return' keyword")?;
        
        let value = if let Some(expr_pair) = inner.next() {
            Some(self.parse_expression(expr_pair)?)
        } else {
            None
        };
        
        Ok(ReturnStatement {
            value,
            span: self.create_span(span),
        })
    }

    /// Parse break statement
    fn parse_break_stmt(&mut self, pair: Pair<Rule>) -> Result<BreakStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        Ok(BreakStatement {
            span: self.create_span(span),
        })
    }

    /// Parse continue statement
    fn parse_continue_stmt(&mut self, pair: Pair<Rule>) -> Result<ContinueStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        Ok(ContinueStatement {
            span: self.create_span(span),
        })
    }

    /// Parse pass statement
    fn parse_pass_stmt(&mut self, pair: Pair<Rule>) -> Result<PassStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        Ok(PassStatement {
            span: self.create_span(span),
        })
    }

    /// Parse raise statement
    fn parse_raise_stmt(&mut self, pair: Pair<Rule>) -> Result<RaiseStatement, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner();
        
        // Skip "raise" keyword
        inner.next().ok_or("Missing 'raise' keyword")?;
        
        let value = self.parse_expression(inner.next().ok_or("Missing expression")?)?;
        
        Ok(RaiseStatement {
            value,
            span: self.create_span(span),
        })
    }

    /// Parse function declaration
    fn parse_function_decl(&mut self, pair: Pair<Rule>) -> Result<FunctionDecl, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let pair_clone = pair.clone();
        
        let mut inner = pair_clone.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        // Parse function name (first token after filtering whitespace)
        let name = inner.next().ok_or("Missing function name")?.as_str().to_string();
        
        // Parse generic parameters (optional)
        let generic_params = Vec::new();
        let mut params = Vec::new();
        
        // Check what the next token is
        if let Some(next_token) = inner.next() {
            match next_token.as_rule() {
                Rule::param_list => {
                    // Function has parameters
                    params = self.parse_param_list(next_token)?;
                    
                    // Parse return type (next token should be type_)
                    let return_type = self.parse_type(inner.next().ok_or("Missing return type")?)?;
                    
                    // Parse function body (next token should be block)
                    let body = self.parse_block(inner.next().ok_or("Missing function body")?)?;
                    
                    return Ok(FunctionDecl {
                        name,
                        generic_params,
                        params,
                        return_type,
                        body,
                        span: self.create_span(span),
                    });
                }
                Rule::type_ => {
                    // Function has no parameters
                    let return_type = self.parse_type(next_token)?;
                    
                    // Parse function body (next token should be block)
                    let body = self.parse_block(inner.next().ok_or("Missing function body")?)?;
                    
                    return Ok(FunctionDecl {
                        name,
                        generic_params,
                        params,
                        return_type,
                        body,
                        span: self.create_span(span),
                    });
                }
                _ => {
                    return Err(format!("Expected param_list or type_, got {:?}", next_token.as_rule()).into());
                }
            }
        }
        
        Err("Missing return type or parameters".into())
    }
    
    /// Parse generic parameters
    fn parse_generic_params(&mut self, pair: Pair<Rule>) -> Result<Vec<GenericParam>, Box<dyn std::error::Error>> {
        let mut params = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        // Skip opening angle bracket
        inner.next().ok_or("Missing opening '<'")?;
        
        while let Some(param_pair) = inner.next() {
            if param_pair.as_rule() == Rule::generic_param {
                let param = self.parse_generic_param(param_pair)?;
                params.push(param);
            } else if param_pair.as_str() == "," {
                // Skip comma
                continue;
            } else if param_pair.as_str() == ">" {
                // End of generic parameters
                break;
            }
        }
        
        Ok(params)
    }
    
    /// Parse single generic parameter
    fn parse_generic_param(&mut self, pair: Pair<Rule>) -> Result<GenericParam, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        let name = inner.next().ok_or("Missing generic parameter name")?.as_str().to_string();
        
        // Skip colon
        inner.next().ok_or("Missing ':'")?;
        
        // Skip "Implements" keyword
        inner.next().ok_or("Missing 'Implements' keyword")?;
        
        // Skip opening bracket
        inner.next().ok_or("Missing opening '['")?;
        
        // Parse bounds
        let mut bounds = Vec::new();
        while let Some(bound_pair) = inner.next() {
            if bound_pair.as_rule() == Rule::identifier {
                bounds.push(bound_pair.as_str().to_string());
            } else if bound_pair.as_str() == "," {
                // Skip comma
                continue;
            } else if bound_pair.as_str() == "]" {
                // End of bounds
                break;
            }
        }
        
        Ok(GenericParam {
            name,
            bounds,
            span: self.create_span(span),
        })
    }
    
    /// Parse parameter list
    fn parse_param_list(&mut self, pair: Pair<Rule>) -> Result<Vec<Parameter>, Box<dyn std::error::Error>> {
        let mut params = Vec::new();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        while let Some(param_pair) = inner.next() {
            if param_pair.as_rule() == Rule::param {
                let param = self.parse_param(param_pair)?;
                params.push(param);
            } else if param_pair.as_str() == "," {
                // Skip comma
                continue;
            }
        }
        
        Ok(params)
    }
    
    /// Parse single parameter
    fn parse_param(&mut self, pair: Pair<Rule>) -> Result<Parameter, Box<dyn std::error::Error>> {
        let span = pair.as_span();
        let mut inner = pair.into_inner().filter(|p| p.as_rule() != Rule::WHITESPACE);
        
        let name = inner.next().ok_or("Missing parameter name")?.as_str().to_string();
        
        let param_type = self.parse_type(inner.next().ok_or("Missing parameter type")?)?;
        
        Ok(Parameter {
            name,
            param_type,
            span: self.create_span(span),
        })
    }

    /// Create a SourceSpan from a pest span
    fn create_span(&self, span: pest::Span) -> SourceSpan {
        let mut files = Files::new();
        let file_id = files.add("input.tj", "");
        SourceSpan::new(file_id, codespan::Span::new(span.start() as u32, span.end() as u32))
    }
}