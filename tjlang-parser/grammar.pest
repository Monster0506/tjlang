// TJLang Grammar for pest
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

program = { SOI ~ program_unit* ~ EOI }

program_unit = { module_decl | import_decl | export_decl | function_decl | type_decl | struct_decl | enum_decl | interface_decl | impl_block | statement }

// Statements
statement = { 
    if_stmt |
    while_stmt |
    do_while_stmt |
    for_stmt |
    match_stmt |
    return_stmt |
    break_stmt |
    continue_stmt |
    pass_stmt |
    raise_stmt |
    variable_decl | 
    expression | 
    block
}

// Blocks
block = { "{" ~ statement* ~ "}" }

// Variable declarations
variable_decl = { identifier ~ ":" ~ type_ ~ "=" ~ expression }

// Control flow statements
if_stmt = { "if" ~ expression ~ block ~ elif_branch* ~ else_branch? }
elif_branch = { "elif" ~ expression ~ block }
else_branch = { "else" ~ block }

while_stmt = { "while" ~ expression ~ block }

do_while_stmt = { "do" ~ block ~ "while" ~ expression }

for_stmt = { "for" ~ "(" ~ identifier ~ ":" ~ type_ ~ "|" ~ expression ~ ")" ~ block }

// Match statements
match_stmt = { "match" ~ expression ~ "{" ~ match_arm+ ~ "}" }
match_arm = { pattern ~ ("if" ~ expression)? ~ ":" ~ block }

// Patterns
pattern = { 
    literal |
    identifier ~ ":" ~ type_ |
    identifier ~ ":" ~ "implements" ~ "[" ~ identifier ~ "]" |
    struct_pattern |
    constructor_pattern |
    "(" ~ pattern ~ ("," ~ pattern)* ~ ")" |
    "_"
}

constructor_pattern = { identifier ~ ("(" ~ pattern_fields? ~ ")")? }
pattern_fields = { pattern ~ ("," ~ pattern)* }

// Struct destructuring patterns
struct_pattern = { identifier ~ "{" ~ struct_pattern_fields? ~ "}" }
struct_pattern_fields = { struct_field_pattern ~ ("," ~ struct_field_pattern)* }
struct_field_pattern = { identifier ~ ":" ~ pattern }

// Simple statements
return_stmt = { "return" ~ expression? }
break_stmt = { "break" }
continue_stmt = { "continue" }
pass_stmt = { "pass" }
raise_stmt = { "raise" ~ expression }

// Function declarations
function_decl = { "def" ~ identifier ~ (generic_params ~ "(" ~ param_list ~ ")" | "(" ~ param_list? ~ ")") ~ "->" ~ type_ ~ block }

generic_params = { "<" ~ generic_param ~ ("," ~ generic_param)* ~ ">" }

generic_param = { identifier ~ ":" ~ "implements" ~ "[" ~ identifier_list ~ "]" }

param_list = { param ~ ("," ~ param)* }

param = { identifier ~ ":" ~ type_ }

identifier_list = { identifier ~ ("," ~ identifier)* }

// Custom type declarations
type_decl = { "type" ~ identifier ~ "=" ~ type_ }

struct_decl = { "type" ~ identifier ~ "{" ~ field_decl ~ ("," ~ field_decl)* ~ "}" }

field_decl = { identifier ~ ":" ~ type_ }

enum_decl = { "enum" ~ identifier ~ (type_param_list)? ~ "{" ~ enum_variant ~ ("," ~ enum_variant)* ~ "}" }

enum_variant = { identifier ~ ("(" ~ variant_fields? ~ ")")? }

variant_fields = { type_ ~ ("," ~ type_)* }

// Type parameter list for enums (just identifiers, no bounds)
type_param_list = { "<" ~ identifier ~ ("," ~ identifier)* ~ ">" }

ARROW = { "->" }

interface_decl = { "interface" ~ interface_name ~ (interface_extends)? ~ "{" ~ method_sig+ ~ "}" }
interface_name = { identifier }
interface_extends = { "extends" ~ identifier_list }

method_sig = { (identifier | operator_symbol) ~ "(" ~ param_list? ~ ")" ~ ARROW ~ type_ }

operator_symbol = { "**" | "+" | "-" | "*" | "/" | "%" | "<<" | ">>" | "&" | "^" | "|" | "==" | "!=" | "<" | ">" | "<=" | ">=" | "[]" | "or" | "and" | "!" | "~" }

impl_block = { "impl" ~ impl_trait_name ~ ":" ~ impl_type_name ~ "{" ~ method_decl ~ "}" }
impl_trait_name = { !keyword ~ (ASCII_ALPHA | "_") ~ ASCII_ALPHANUMERIC* }
impl_type_name = { !keyword ~ (ASCII_ALPHA | "_") ~ ASCII_ALPHANUMERIC* }

method_decl = { (identifier | operator_symbol) ~ "(" ~ param_list? ~ ")" ~ ARROW ~ type_ ~ block }

// Types
type_ = { union_type }
union_type = { option_type ~ ("|" ~ option_type)* }
option_type = { "?"? ~ function_type }
function_type = { "(" ~ type_list? ~ ")" ~ "->" ~ (collection_type | primary_type) | collection_type | primary_type }
collection_type = { vec_type | set_type | map_type | tuple_type }
vec_type = { "[" ~ type_ ~ "]" }
set_type = { "{" ~ type_ ~ "}" }
map_type = { primary_type ~ "<" ~ type_ ~ "," ~ type_ ~ ">" }
tuple_type = { "(" ~ type_ ~ ("," ~ type_)+ ~ ")" }
primary_type = { primitive_type | identifier ~ type_params? | result_type | option_wrapper }
result_type = { "Result" ~ "<" ~ type_ ~ "," ~ type_ ~ ">" }
option_wrapper = { "Option" ~ "<" ~ type_ ~ ">" }
type_params = { "<" ~ type_ ~ ("," ~ type_)* ~ ">" }
type_list = { type_ ~ ("," ~ type_)* }
primitive_type = { "int" | "float" | "bool" | "str" | "any" }

// Expressions (with proper precedence - right associative to avoid left recursion)
expression = { assignment }
assignment = { or_expr ~ ("=" ~ expression)? }
or_expr = { and_expr ~ ("or" ~ and_expr)* }
and_expr = { bit_or_expr ~ ("and" ~ bit_or_expr)* }
bit_or_expr = { bit_xor_expr ~ ("|" ~ bit_xor_expr)* }
bit_xor_expr = { bit_and_expr ~ ("^" ~ bit_and_expr)* }
bit_and_expr = { equality ~ ("&" ~ equality)* }
equality = { relational ~ (("==" | "!=") ~ relational)* }
relational = { shift_expr ~ (("<=" | ">=" | "<" | ">") ~ shift_expr)* }
shift_expr = { additive ~ (("<<" | ">>") ~ additive)* }
additive = { multiplicative ~ (("+" | "-") ~ multiplicative)* }
multiplicative = { power ~ (("*" | "/" | "%") ~ power)* }
power = { unary ~ ("**" ~ power)? }
unary = { ("-" | "!" | "~" | "not")? ~ postfix_expr }
postfix_expr = { primary ~ (call_suffix | index_suffix | member_suffix)* }
primary = { spawn_expr | range_expr | literal | identifier | collection_literal | lambda_expr | "(" ~ expression ~ ")" }
spawn_expr = { "spawn" ~ expression }

// Literals
literal = { 
    float_literal | 
    integer_literal | 
    string_literal | 
    fstring_literal |
    boolean_literal | 
    none_literal
}

// Basic literals
integer_literal = { "-"? ~ ASCII_DIGIT+ }
float_literal = { "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
string_literal = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
fstring_literal = { "f\"" ~ (!"\"" ~ ANY)* ~ "\""}
boolean_literal = { "true" | "false" }
none_literal = { "None" }

// Collection literals
collection_literal = { vec_literal | map_literal | set_literal | tuple_literal | struct_literal }

vec_literal = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }
set_literal = { "{" ~ (expression ~ ("," ~ expression)*)? ~ "}" }
map_literal = { "{" ~ (map_entry ~ ("," ~ map_entry)*)? ~ "}" }
tuple_literal = { "(" ~ expression ~ ("," ~ expression)+ ~ ")" }

struct_literal = { identifier ~ "{" ~ field_init ~ ("," ~ field_init)* ~ "}" }

map_entry = { expression ~ ":" ~ expression }

// Field initialization for struct literals
field_init = { identifier ~ ":" ~ expression }

// Postfix expressions
call_suffix = { "(" ~ (argument_list | field_init_list)? ~ ")" }
index_suffix = { "[" ~ expression ~ "]" }
member_suffix = { "." ~ identifier }

// Lambda expressions
lambda_expr = { "(" ~ param_list? ~ ")" ~ "->" ~ expression }

// Range expressions
range_expr = { integer_literal ~ ".." ~ ("=" ~ integer_literal | integer_literal)? }

// Argument lists
argument_list = { expression ~ ("," ~ expression)* }

// Field initialization list for struct literals in function calls
field_init_list = { field_init ~ ("," ~ field_init)* }

// Identifiers
impl_kw = { "impl" }
for_kw = { "for" }
keyword = { impl_kw | for_kw | "module" | "import" | "from" | "export" | "as" | "do" | "spawn" | "def" | "type" | "enum" | "interface" | "if" | "elif" | "else" | "while" | "match" | "return" | "break" | "continue" | "pass" | "raise" | "implements" | "extends" | "true" | "false" | "None" | "not" }
identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }

// Qualified names (for modules/imports)
qualified_name = { identifier ~ ("." ~ identifier)* }

// Module/import/export declarations
module_decl = { "module" ~ qualified_name }

import_decl = { "import" ~ (
    // Selective import: import { a, b } from pkg.name
    "{" ~ identifier_list ~ "}" ~ "from" ~ qualified_name
    |
    // Simple import with optional alias: import pkg.name [as alias]
    qualified_name ~ ("as" ~ identifier)?
) }

export_decl = { "export" ~ ( identifier | "{" ~ identifier_list ~ "}" ) }
