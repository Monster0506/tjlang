// TJLang Grammar for pest
WHITESPACE = { " " | "\t" | "\r" | "\n" }
COMMENT = { "#" ~ (!"\n" ~ ANY)* }

program = { SOI ~ program_unit* ~ EOI }

program_unit = { function_decl | statement }

// Statements
statement = { 
    if_stmt |
    while_stmt |
    for_stmt |
    return_stmt |
    break_stmt |
    continue_stmt |
    pass_stmt |
    raise_stmt |
    variable_decl | 
    expression | 
    block
}

// Blocks
block = { "{" ~ statement* ~ "}" }

// Variable declarations
variable_decl = { identifier ~ ":" ~ type_ ~ "=" ~ expression }

// Control flow statements
if_stmt = { "if" ~ expression ~ block ~ elif_branch* ~ else_branch? }
elif_branch = { "elif" ~ expression ~ block }
else_branch = { "else" ~ block }

while_stmt = { "while" ~ expression ~ block }

for_stmt = { "for" ~ "(" ~ identifier ~ ":" ~ type_ ~ "|" ~ expression ~ ")" ~ block }

// Simple statements
return_stmt = { "return" ~ expression? }
break_stmt = { "break" }
continue_stmt = { "continue" }
pass_stmt = { "pass" }
raise_stmt = { "raise" ~ expression }

// Function declarations
function_decl = { "def" ~ identifier ~ (generic_params ~ "(" ~ param_list ~ ")" | "(" ~ param_list? ~ ")") ~ "->" ~ type_ ~ block }

generic_params = { "<" ~ generic_param ~ ("," ~ generic_param)* ~ ">" }

generic_param = { identifier ~ ":" ~ "Implements" ~ "[" ~ identifier_list ~ "]" }

param_list = { param ~ ("," ~ param)* }

param = { identifier ~ ":" ~ type_ }

identifier_list = { identifier ~ ("," ~ identifier)* }

// Types
type_ = { primitive_type | identifier }
primitive_type = { "int" | "float" | "bool" | "str" | "any" }

// Expressions (with proper precedence - right associative to avoid left recursion)
expression = { assignment }
assignment = { or_expr ~ ("=" ~ expression)? }
or_expr = { and_expr ~ ("or" ~ and_expr)* }
and_expr = { equality ~ ("and" ~ equality)* }
equality = { relational ~ (("==" | "!=") ~ relational)* }
relational = { additive ~ (("<=" | ">=" | "<" | ">") ~ additive)* }
additive = { multiplicative ~ (("+" | "-") ~ multiplicative)* }
multiplicative = { unary ~ (("*" | "/" | "%") ~ unary)* }
unary = { ("-" | "!")? ~ primary }
primary = { literal | identifier | collection_literal | "(" ~ expression ~ ")" }

// Literals
literal = { 
    float_literal | 
    integer_literal | 
    string_literal | 
    boolean_literal | 
    none_literal
}

// Basic literals
integer_literal = { "-"? ~ ASCII_DIGIT+ }
float_literal = { "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
string_literal = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
boolean_literal = { "true" | "false" }
none_literal = { "None" }

// Collection literals
collection_literal = { vec_literal | map_literal | set_literal | tuple_literal }

vec_literal = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }
set_literal = { "{" ~ (expression ~ ("," ~ expression)*)? ~ "}" }
map_literal = { "{" ~ (map_entry ~ ("," ~ map_entry)*)? ~ "}" }
tuple_literal = { "(" ~ expression ~ ("," ~ expression)+ ~ ")" }

map_entry = { expression ~ ":" ~ expression }

// Identifiers
identifier = { (ASCII_ALPHA | "_") ~ ASCII_ALPHANUMERIC* }